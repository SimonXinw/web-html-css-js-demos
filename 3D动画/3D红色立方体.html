<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js 滚轮缩放摄像头</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();

    // 初始相机设置
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(3, 3, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 定义几何体
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      -1, -1, -1,  1, -1, -1,  1, -1,  1,  -1, -1,  1,
      -1, -1,  1,  1, -1,  1,  1,  1,  1,  -1,  1,  1,
      -1, -1, -1, -1,  1, -1,  1,  1, -1,   1, -1, -1,
      -1, -1, -1, -1, -1,  1, -1,  1,  1,  -1,  1, -1,
       1, -1, -1,  1,  1, -1,  1,  1,  1,   1, -1,  1
    ]);

    const indices = [
       0,  1,  2,  0,  2,  3,
       4,  5,  6,  4,  6,  7,
       8,  9, 10,  8, 10, 11,
      12, 13, 14, 12, 14, 15,
      16, 17, 18, 16, 18, 19
    ];

    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    const material = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // 渲染函数（每次更新）
    function render() {
      renderer.render(scene, camera);
    }

    render();

    // 滚轮缩放（调整摄像头距离）
    window.addEventListener('wheel', (event) => {
      event.preventDefault();

      // 缩放速度
      const zoomSpeed = 0.5;

      // 向上滚：缩小（靠近物体） / 向下滚：放大（远离物体）
      const delta = event.deltaY > 0 ? 1 : -1;

      // 计算相机新位置（保持方向）
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir); // 获取相机方向
      camera.position.addScaledVector(dir, delta * zoomSpeed);

      render();
    });

    // 窗口尺寸变化响应
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    });
  </script>
</body>
</html>
