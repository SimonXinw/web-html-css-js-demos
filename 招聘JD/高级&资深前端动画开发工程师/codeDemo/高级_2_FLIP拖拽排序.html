<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>FLIP 拖拽排序动画</title>
    <style>
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 50px; 
            background: #f0f2f5; 
        }
        
        .list { 
            width: 300px; 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
            position: relative;
        }
        
        .item {
            background: white; 
            padding: 15px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            cursor: move; 
            user-select: none;
            transition: box-shadow 0.2s;
        }
        
        .item:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .btn { 
            margin-bottom: 20px; 
            padding: 10px 20px; 
            cursor: pointer; 
            background: #333; 
            color: white; 
            border: none; 
            border-radius: 4px; 
        }
        
        .btn:hover {
            background: #555;
        }
        
        .interview-box { 
            width: 600px; 
            margin-top: 50px; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
        }
    </style>
</head>
<body>

    <button class="btn" onclick="shuffleList()">随机乱序 (应用 FLIP 动画)</button>

    <div class="list" id="list">
        <div class="item" draggable="true" id="item-1">Item 1</div>
        <div class="item" draggable="true" id="item-2">Item 2</div>
        <div class="item" draggable="true" id="item-3">Item 3</div>
        <div class="item" draggable="true" id="item-4">Item 4</div>
        <div class="item" draggable="true" id="item-5">Item 5</div>
    </div>

    <script>
        const list = document.getElementById('list');
        let draggedElement = null;
        let lastDragPosition = null;
        let ticking = false;

        // ==========================================
        // 拖拽功能实现（优化版）
        // ==========================================
        
        // 拖拽开始
        list.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('item')) {
                draggedElement = e.target;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                
                // 记录初始位置，用于 FLIP 动画
                const items = Array.from(list.children);
                items.forEach(item => {
                    const rect = item.getBoundingClientRect();
                    item.dataset.startTop = rect.top;
                    item.dataset.startLeft = rect.left;
                });
            }
        });

        // 拖拽结束
        list.addEventListener('dragend', (e) => {
            if (e.target.classList.contains('item')) {
                e.target.classList.remove('dragging');
                lastDragPosition = null;
            }
        });

        // 拖拽经过（使用 requestAnimationFrame 节流优化）
        list.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            if (!ticking) {
                requestAnimationFrame(() => {
                    updateDragPosition(e.clientY);
                    ticking = false;
                });
                ticking = true;
            }
        });

        // 更新拖拽位置
        function updateDragPosition(y) {
            const afterElement = getDragAfterElement(list, y);
            const dragging = document.querySelector('.dragging');
            
            if (!dragging) return;
            
            // 只在位置真正改变时才移动 DOM
            if (afterElement !== lastDragPosition) {
                lastDragPosition = afterElement;
                
                if (afterElement == null) {
                    list.appendChild(dragging);
                } else {
                    list.insertBefore(dragging, afterElement);
                }
                
                // 实时应用平滑动画
                applyRealtimeFLIPAnimation();
            }
        }


        // 放置
        list.addEventListener('drop', (e) => {
            e.preventDefault();
            // 最终动画已经在实时应用了，这里只需要清理
            const items = Array.from(list.children);
            items.forEach(item => {
                delete item.dataset.startTop;
                delete item.dataset.startLeft;
            });
        });

        // 获取拖拽后应该插入的位置
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // ==========================================
        // 实时 FLIP 动画（拖拽过程中）
        // ==========================================
        
        function applyRealtimeFLIPAnimation() {
            const items = Array.from(list.children).filter(item => !item.classList.contains('dragging'));
            
            items.forEach(item => {
                // 获取当前位置
                const currentRect = item.getBoundingClientRect();
                const startTop = parseFloat(item.dataset.startTop || currentRect.top);
                
                // 计算位移
                const deltaY = startTop - currentRect.top;
                
                if (Math.abs(deltaY) > 0.5) {
                    // 应用反向变换
                    item.style.transform = `translateY(${deltaY}px)`;
                    item.style.transition = 'none';
                    
                    // 强制重排
                    item.offsetHeight;
                    
                    // 启用过渡并移除 transform
                    item.style.transition = 'transform 0.25s cubic-bezier(0.4, 0, 0.2, 1)';
                    item.style.transform = 'translateY(0)';
                }
                
                // 更新起始位置
                item.dataset.startTop = currentRect.top;
            });
        }

        // ==========================================
        // 随机乱序功能
        // ==========================================
        
        function shuffleList() {
            const items = Array.from(list.children);

            // 1. First: 记录初始位置
            const firstPositions = new Map();
            items.forEach(item => {
                firstPositions.set(item, item.getBoundingClientRect());
            });

            // 2. Last: 执行 DOM 操作（改变布局）
            const shuffled = items.sort(() => Math.random() - 0.5);
            shuffled.forEach(item => list.appendChild(item));

            // 3. Invert: 计算位置差并应用反向变换
            items.forEach(item => {
                const first = firstPositions.get(item);
                const last = item.getBoundingClientRect();

                const deltaX = first.left - last.left;
                const deltaY = first.top - last.top;

                if (deltaX !== 0 || deltaY !== 0) {
                    item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    item.style.transition = 'none';
                }
            });

            // 4. Play: 启用过渡并移除 transform
            requestAnimationFrame(() => {
                items.forEach(item => {
                    item.style.transition = 'transform 0.5s cubic-bezier(0.2, 0, 0.2, 1)';
                    item.style.transform = '';
                });
            });
        }
    </script>

    <div class="interview-box">
        <h3>面试考察点：</h3>
        <p><strong>1. 什么是 FLIP 动画技术？</strong></p>
        <!-- 
            答案：
            FLIP 是一种实现高性能布局动画的方法论，由 Google 提出。
            - First: 记录元素在动画开始前的初始状态（位置、大小等）。
            - Last: 执行布局变更（如 DOM 排序、增删），记录元素的最终状态。
            - Invert: 计算 First 和 Last 的差值，使用 transform 将元素"反向"平移回初始视觉位置。这让元素看起来好像还在原地。
            - Play: 启用 transition，移除 transform，让元素从"假"的初始位置平滑过渡到"真"的最终位置。
        -->

        <p><strong>2. 为什么要用 FLIP？</strong></p>
        <!-- 
            答案：
            直接加 transition: all 在很多场景下无效或性能差：
            1. 布局突变：如果是 DOM 节点顺序改变（如 appendChild 移动节点），浏览器会直接重排，无法自动生成补间动画。
            2. 性能问题：如果用 absolute 定位并改变 top/left，会触发 Layout（重排），性能消耗大。
            3. FLIP 的优势：整个动画过程只改变 transform 和 opacity，只触发 Composite（合成），由 GPU 处理，能保证 60FPS 流畅度。
        -->

        <p><strong>3. 拖拽排序的核心原理是什么？</strong></p>
        <!-- 
            答案：
            使用 HTML5 Drag and Drop API 实现拖拽功能：
            
            1. dragstart：拖拽开始时，记录被拖拽的元素
            2. dragover：拖拽经过时，计算应该插入的位置，实时调整 DOM 顺序
            3. drop：放置时，应用 FLIP 动画让元素平滑过渡到新位置
            
            关键函数 getDragAfterElement：
            - 遍历所有非拖拽元素，计算鼠标位置与每个元素中心的距离
            - 找到最接近的元素，返回应该插入的位置
            - 使用 insertBefore 实时调整 DOM 顺序
            
            为什么要实时调整 DOM：
            让拖拽过程更直观，用户可以看到元素实时移动到新位置。
        -->

        <p><strong>4. draggable 属性的作用是什么？</strong></p>
        <!-- 
            答案：
            draggable 是 HTML5 的全局属性，控制元素是否可以被拖拽。
            
            取值：
            - true：元素可拖拽
            - false：元素不可拖拽
            - auto：默认行为（图片和链接默认可拖拽，其他元素不可拖拽）
            
            本例中：
            <div class="item" draggable="true">Item 1</div>
            
            如果不加 draggable="true"：
            元素无法触发 dragstart 事件，拖拽功能失效。
            
            注意：
            draggable 只是让元素"可拖拽"，具体的拖拽行为需要通过 JavaScript 监听拖拽事件来实现。
        -->

        <p><strong>5. e.dataTransfer 的作用是什么？</strong></p>
        <!-- 
            答案：
            dataTransfer 是拖拽事件对象的属性，用于在拖拽过程中传递数据。
            
            常用属性和方法：
            1. effectAllowed：设置允许的拖拽效果（move、copy、link 等）
            2. dropEffect：设置实际的拖拽效果（在 dragover 中设置）
            3. setData(type, data)：存储数据
            4. getData(type)：获取数据
            
            本例中：
            e.dataTransfer.effectAllowed = 'move';  // 设置为移动效果
            e.dataTransfer.dropEffect = 'move';     // 显示移动光标
            
            为什么要设置这些：
            - 告诉浏览器这是"移动"操作，而不是"复制"或"链接"
            - 浏览器会显示相应的光标样式（移动光标）
            - 提升用户体验，让拖拽意图更明确
        -->

        <p><strong>6. 为什么要在 dragover 中调用 e.preventDefault()？</strong></p>
        <!-- 
            答案：
            默认情况下，浏览器不允许在元素上"放置"（drop）。
            
            如果不调用 e.preventDefault()：
            - drop 事件不会触发
            - 拖拽操作会被取消
            - 元素会回到原位置
            
            调用 e.preventDefault() 后：
            - 告诉浏览器："我允许在这里放置"
            - drop 事件可以正常触发
            - 拖拽操作可以完成
            
            这是 HTML5 拖拽 API 的设计：
            必须显式允许放置，防止意外的拖拽操作。
        -->

        <p><strong>7. getDragAfterElement 函数的算法原理是什么？</strong></p>
        <!-- 
            答案：
            这个函数用于计算拖拽元素应该插入的位置。
            
            算法步骤：
            1. 获取所有非拖拽元素（排除正在拖拽的元素）
            2. 遍历每个元素，计算鼠标 Y 坐标与元素中心的距离
            3. 使用 reduce 找到距离最小且在鼠标上方的元素
            
            关键计算：
            const offset = y - box.top - box.height / 2;
            - y：鼠标的 Y 坐标
            - box.top + box.height / 2：元素中心的 Y 坐标
            - offset：鼠标距离元素中心的距离
            
            判断逻辑：
            if (offset < 0 && offset > closest.offset)
            - offset < 0：鼠标在元素上方
            - offset > closest.offset：距离比当前最近的元素更近
            
            返回值：
            - 返回应该插入的位置（在这个元素之前插入）
            - 如果没有找到，返回 null（插入到末尾）
        -->

        <p><strong>8. 如何优化拖拽排序的性能？</strong></p>
        <!-- 
            答案：
            当前代码已经使用了 FLIP 技术，性能较好，但仍有优化空间：
            
            1. 节流 dragover 事件：
               dragover 事件触发频率很高（每移动 1px 触发一次）
               可以使用 requestAnimationFrame 节流：
               
               let ticking = false;
               list.addEventListener('dragover', (e) => {
                   if (!ticking) {
                       requestAnimationFrame(() => {
                           // 处理逻辑
                           ticking = false;
                       });
                       ticking = true;
                   }
               });
            
            2. 使用 will-change 提示浏览器：
               .item {
                   will-change: transform;
               }
            
            3. 虚拟化长列表：
               如果列表有几百个元素，只渲染可见区域的元素。
            
            4. 使用 Web Workers：
               将位置计算移到 Worker 线程，避免阻塞主线程。
            
            5. 减少 DOM 操作：
               当前代码在 dragover 中频繁调用 insertBefore，可以优化为只在必要时调用。
        -->
    </div>
</body>
</html>
