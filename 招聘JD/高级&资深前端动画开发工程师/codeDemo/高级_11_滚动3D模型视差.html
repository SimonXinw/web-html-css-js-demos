<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>滚动3D模型视差动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Arial", sans-serif;
            overflow-x: hidden;
            background: #0a0a0a;
        }

        /* 3D 场景容器 */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }

        /* 内容区域 */
        .content-section {
            position: relative;
            z-index: 2;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 100px 20px;
            color: #fff;
        }

        .text-content {
            max-width: 800px;
            text-align: center;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .text-content.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .text-content h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .text-content h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #81d4fa;
        }

        .text-content p {
            font-size: 1.2rem;
            line-height: 1.8;
            color: #b0bec5;
            margin-bottom: 15px;
        }

        /* 滚动提示 */
        .scroll-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* 响应式 */
        @media (max-width: 768px) {
            .text-content h1 {
                font-size: 2rem;
            }

            .text-content h2 {
                font-size: 1.5rem;
            }

            .text-content p {
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div class="content-section" id="section1">
        <div class="text-content" id="text1">
            <h1>探索无限可能</h1>
            <p>在数字世界中，每一个像素都承载着无限创意</p>
        </div>
    </div>

    <div class="content-section" id="section2">
        <div class="text-content" id="text2">
            <h2>创新设计</h2>
            <p>将想象力转化为现实，用技术点亮未来</p>
        </div>
    </div>

    <div class="content-section" id="section3">
        <div class="text-content" id="text3">
            <h2>极致体验</h2>
            <p>每一个细节都经过精心打磨，追求完美的用户体验</p>
        </div>
    </div>

    <div class="content-section" id="section4">
        <div class="text-content" id="text4">
            <h2>持续进化</h2>
            <p>在不断的学习与实践中，创造更美好的数字世界</p>
        </div>
    </div>

    <div class="scroll-hint">向下滚动查看更多</div>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script> -->
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
          }
        }
      </script>


    <script type="module">
        import * as THREE from "three";

        // 场景设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById("canvas-container").appendChild(renderer.domElement);

        // 相机初始位置
        camera.position.z = 5;

        // 创建精美人物模型
        const createCharacter = (color, scale = 1) => {
            const character = new THREE.Group();

            // 身体材质
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.6,
                roughness: 0.4,
                emissive: color,
                emissiveIntensity: 0.1
            });

            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdbac,
                metalness: 0.3,
                roughness: 0.7
            });

            // 头部
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.3 * scale, 16, 16),
                headMaterial
            );
            head.position.y = 1.2 * scale;
            character.add(head);

            // 身体
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 0.8 * scale, 16),
                bodyMaterial
            );
            body.position.y = 0.4 * scale;
            character.add(body);

            // 左臂组（用于更好的旋转控制）
            const leftArmGroup = new THREE.Group();
            const leftArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 0.6 * scale, 8),
                bodyMaterial
            );
            leftArm.rotation.z = Math.PI / 2; // 旋转90度让手臂水平
            leftArm.position.x = -0.3 * scale; // 手臂在组内的位置
            leftArmGroup.position.set(-0.4 * scale, 0.6 * scale, 0);
            leftArmGroup.add(leftArm);
            character.add(leftArmGroup);

            // 右臂组
            const rightArmGroup = new THREE.Group();
            const rightArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08 * scale, 0.1 * scale, 0.6 * scale, 8),
                bodyMaterial
            );
            rightArm.rotation.z = Math.PI / 2; // 旋转90度让手臂水平
            rightArm.position.x = 0.3 * scale; // 手臂在组内的位置
            rightArmGroup.position.set(0.4 * scale, 0.6 * scale, 0);
            rightArmGroup.add(rightArm);
            character.add(rightArmGroup);

            // 左腿
            const leftLeg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1 * scale, 0.12 * scale, 0.7 * scale, 8),
                bodyMaterial
            );
            leftLeg.position.set(-0.15 * scale, -0.35 * scale, 0);
            character.add(leftLeg);

            // 右腿
            const rightLeg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1 * scale, 0.12 * scale, 0.7 * scale, 8),
                bodyMaterial
            );
            rightLeg.position.set(0.15 * scale, -0.35 * scale, 0);
            character.add(rightLeg);

            // 存储部件引用用于动画
            character.userData.parts = {
                leftArm: leftArmGroup,  // 使用组而不是单独的mesh
                rightArm: rightArmGroup, // 使用组而不是单独的mesh
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                body: body,
                head: head
            };

            return character;
        };

        // 模型数组
        const models = [];

        // 每个场景的模型配置（每个场景1-3个模型）
        const sceneConfigs = [
            // 场景1：四面体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.TetrahedronGeometry(1, 0),
                    color: 0x667eea,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0x667eea,
                    scale: 0.8,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // 场景2：立方体 + 八面体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.BoxGeometry(1.2, 1.2, 1.2),
                    color: 0x764ba2,
                    offset: { x: -1.8, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.OctahedronGeometry(0.9, 0),
                    color: 0xf093fb,
                    offset: { x: 0, y: 0, z: -1 }
                },
                {
                    type: "character",
                    color: 0x764ba2,
                    scale: 0.9,
                    offset: { x: 1.8, y: 0, z: 0 }
                }
            ],
            // 场景3：二十面体 + 人物 + 球体
            [
                {
                    type: "geometry",
                    geometry: new THREE.IcosahedronGeometry(1, 0),
                    color: 0x4facfe,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0x4facfe,
                    scale: 1,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.SphereGeometry(0.8, 16, 16),
                    color: 0x00d4ff,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // 场景4：多个几何体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.TorusGeometry(0.8, 0.3, 8, 16),
                    color: 0xff6b9d,
                    offset: { x: -2, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0xff6b9d,
                    scale: 1.1,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.ConeGeometry(0.9, 1.5, 8),
                    color: 0xffa500,
                    offset: { x: 2, y: 0, z: 0 }
                }
            ]
        ];

        // 创建所有模型
        sceneConfigs.forEach((sceneModels, sceneIndex) => {
            sceneModels.forEach((config, modelIndex) => {
                let mesh;

                if (config.type === "character") {
                    mesh = createCharacter(config.color, config.scale);
                } else {
                    const material = new THREE.MeshStandardMaterial({
                        color: config.color,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: config.color,
                        emissiveIntensity: 0.2
                    });
                    mesh = new THREE.Mesh(config.geometry, material);
                }

                mesh.userData = {
                    sceneIndex: sceneIndex,
                    modelIndex: modelIndex,
                    initialScale: 0.1,
                    targetScale: 1,
                    rotationSpeedX: 0.01 + sceneIndex * 0.003 + modelIndex * 0.001,
                    rotationSpeedY: 0.012 + sceneIndex * 0.004 + modelIndex * 0.001,
                    rotationSpeedZ: 0.008 + sceneIndex * 0.002 + modelIndex * 0.001,
                    offset: config.offset || { x: 0, y: 0, z: 0 },
                    isCharacter: config.type === "character",
                    animationTime: 0
                };

                // 初始位置：右上角
                mesh.position.set(10, 5, 0);
                mesh.scale.set(0.1, 0.1, 0.1);
                scene.add(mesh);
                models.push(mesh);
            });
        });

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x667eea, 1, 100);
        pointLight.position.set(-5, 5, 5);
        scene.add(pointLight);

        // 滚动控制
        let scrollProgress = 0;
        const sectionHeight = window.innerHeight;
        const totalSections = 4;

        // 更新模型状态
        const updateModels = () => {
            models.forEach((model) => {
                const sectionStart = model.userData.sceneIndex * sectionHeight;
                const sectionEnd = (model.userData.sceneIndex + 1) * sectionHeight;
                const sectionProgress = (window.scrollY - sectionStart) / sectionHeight;

                // 进入阶段（0-0.3）：从右上角飘到中间
                if (window.scrollY >= sectionStart && window.scrollY < sectionStart + sectionHeight * 0.3) {
                    const enterProgress = Math.min(sectionProgress / 0.3, 1);
                    const easeProgress = 1 - Math.pow(1 - enterProgress, 3); // 缓动函数

                    // 位置：从右上角到中间（加上偏移量）
                    const targetX = model.userData.offset.x;
                    const targetY = model.userData.offset.y;
                    const targetZ = model.userData.offset.z;

                    model.position.x = 10 - (10 - targetX) * easeProgress;
                    model.position.y = 5 - (5 - targetY) * easeProgress;
                    model.position.z = 0 - (0 - targetZ) * easeProgress;

                    // 缩放：从小到大
                    const scale = model.userData.initialScale + (model.userData.targetScale - model.userData.initialScale) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(enterProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 停留阶段（0.3-0.7）：在中间停留并自动旋转，不受滚动影响
                else if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionStart + sectionHeight * 0.7) {
                    // 位置保持在中间（加上偏移量）
                    model.position.x = model.userData.offset.x;
                    model.position.y = model.userData.offset.y;
                    model.position.z = model.userData.offset.z;

                    // 缩放保持目标大小
                    model.scale.set(model.userData.targetScale, model.userData.targetScale, model.userData.targetScale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        // 计算在停留阶段的滚动进度（0-1）
                        const stayProgress = (window.scrollY - (sectionStart + sectionHeight * 0.3)) / (sectionHeight * 0.4);
                        // 使用 sin 函数根据滚动位置实现左右摇摆
                        const swingAngle = Math.sin(stayProgress * Math.PI * 4) * 0.4; // 左右摇摆约23度
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 退出阶段（0.7-1.0）：从中间到左下角消失
                else if (window.scrollY >= sectionStart + sectionHeight * 0.7 && window.scrollY < sectionEnd) {
                    const exitProgress = (sectionProgress - 0.7) / 0.3;
                    const easeProgress = Math.pow(exitProgress, 2); // 缓动函数

                    // 位置：从中间到左下角
                    const startX = model.userData.offset.x;
                    const startY = model.userData.offset.y;
                    const startZ = model.userData.offset.z;

                    model.position.x = startX - (startX - (-10)) * easeProgress;
                    model.position.y = startY - (startY - (-5)) * easeProgress;
                    model.position.z = startZ - (startZ - 5) * easeProgress;

                    // 缩放：从大到小
                    const scale = model.userData.targetScale - (model.userData.targetScale - 0.1) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(exitProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 其他阶段：隐藏
                else {
                    model.visible = false;
                }
            });
        };

        // 更新文字显示
        const updateTexts = () => {
            const texts = document.querySelectorAll(".text-content");
            texts.forEach((text, index) => {
                const sectionStart = index * sectionHeight;
                const sectionEnd = (index + 1) * sectionHeight;

                if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionEnd) {
                    text.classList.add("visible");
                } else {
                    text.classList.remove("visible");
                }
            });
        };

        // 滚动事件
        let ticking = false;
        const onScroll = () => {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    updateModels();
                    updateTexts();
                    ticking = false;
                });
                ticking = true;
            }
        };

        window.addEventListener("scroll", onScroll);
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始更新
        updateModels();
        updateTexts();


        // 动画循环
        let lastTime = performance.now();
        const animate = (currentTime) => {
            requestAnimationFrame(animate);

            // 确保时间正确计算
            if (!currentTime) {
                currentTime = performance.now();
            }
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // 限制最大deltaTime
            lastTime = currentTime;

            // 如果deltaTime为0或无效，使用固定值
            const validDeltaTime = deltaTime > 0 ? deltaTime : 0.016;

            // 持续旋转所有可见的模型（3D无序旋转）
            models.forEach((model) => {
                if (model.visible) {
                    // 检查模型是否在停留阶段（中间位置）
                    const sectionStart = model.userData.sceneIndex * sectionHeight;
                    const isInCenter = window.scrollY >= sectionStart + sectionHeight * 0.3 &&
                        window.scrollY < sectionStart + sectionHeight * 0.7;

                    if (!model.userData.isCharacter) {
                        // 几何体模型：进行3D无序旋转
                        if (isInCenter) {
                            // 在中间时，进行3D无序旋转
                            model.rotation.x += model.userData.rotationSpeedX;
                            model.rotation.y += model.userData.rotationSpeedY;
                            model.rotation.z += model.userData.rotationSpeedZ;
                        } else {
                            // 其他阶段也保持旋转，但速度稍慢
                            model.rotation.x += model.userData.rotationSpeedX * 0.5;
                            model.rotation.y += model.userData.rotationSpeedY * 0.5;
                            model.rotation.z += model.userData.rotationSpeedZ * 0.5;
                        }
                    }
                }
            });

            renderer.render(scene, camera);
        };

        animate(0);
    </script>
</body>

</html>