<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>滚动3D模型视差动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Arial", sans-serif;
            overflow-x: hidden;
            background: #0a0a0a;
        }

        /* 3D 场景容器 */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }

        /* 内容区域 */
        .content-section {
            position: relative;
            z-index: 2;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 100px 20px;
            color: #fff;
        }

        .text-content {
            max-width: 800px;
            text-align: center;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .text-content.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .text-content h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .text-content h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #81d4fa;
        }

        .text-content p {
            font-size: 1.2rem;
            line-height: 1.8;
            color: #b0bec5;
            margin-bottom: 15px;
        }

        /* 滚动提示 */
        .scroll-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* 响应式 */
        @media (max-width: 768px) {
            .text-content h1 {
                font-size: 2rem;
            }

            .text-content h2 {
                font-size: 1.5rem;
            }

            .text-content p {
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div class="content-section" id="section1">
        <div class="text-content" id="text1">
            <h1>探索无限可能</h1>
            <p>在数字世界中，每一个像素都承载着无限创意</p>
        </div>
    </div>

    <div class="content-section" id="section2">
        <div class="text-content" id="text2">
            <h2>创新设计</h2>
            <p>将想象力转化为现实，用技术点亮未来</p>
        </div>
    </div>

    <div class="content-section" id="section3">
        <div class="text-content" id="text3">
            <h2>极致体验</h2>
            <p>每一个细节都经过精心打磨，追求完美的用户体验</p>
        </div>
    </div>

    <div class="content-section" id="section4">
        <div class="text-content" id="text4">
            <h2>持续进化</h2>
            <p>在不断的学习与实践中，创造更美好的数字世界</p>
        </div>
    </div>

    <div class="scroll-hint">向下滚动查看更多</div>

    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
          }
        }
      </script>


    <script type="module">
        import * as THREE from "three";
        import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
        import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
        import { TGALoader } from "three/addons/loaders/TGALoader.js";

        // 创建 LoadingManager 并注册 TGALoader
        const manager = new THREE.LoadingManager();
        manager.addHandler(/\.tga$/i, new TGALoader());

        // 场景设置
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById("canvas-container").appendChild(renderer.domElement);

        // 相机初始位置
        camera.position.z = 5;

        // 加载精美人物模型 (异步)
        const loadCharacterModel = async (scale = 1) => {
            return new Promise((resolve, reject) => {
                const modelPath = "../../../3D动画/module/rem/"; // 相对路径：从 codeDemo -> 根目录 -> 3D动画
                const mtlLoader = new MTLLoader(manager);
                mtlLoader.setPath(modelPath);

                mtlLoader.load("untitled.mtl", (materials) => {
                    materials.preload();

                    const objLoader = new OBJLoader(manager);
                    objLoader.setMaterials(materials);
                    objLoader.setPath(modelPath);

                    objLoader.load(
                        "untitled.obj",
                        (object) => {
                            // 缩放修正：这里的 scale 只是基础缩放，具体大小可能需要微调
                            // 原模型较大，可能需要缩小
                            const baseScale = scale; // 预估缩放系数
                            object.scale.set(baseScale, baseScale, baseScale);

                            object.position.y = 0; // 确保底部对齐

                            // 遍历并检查材质，强制更新，修复颜色
                            object.traverse((child) => {
                                if (child.isMesh) {
                                    const mats = Array.isArray(child.material) ? child.material : [child.material];
                                    mats.forEach(mat => {
                                        mat.needsUpdate = true;
                                        // 强制白色底色，防止 MTL 里的深色 Kd 影响纹理显示
                                        if (mat.color) mat.color.setHex(0xffffff);
                                        if (mat.map) mat.map.needsUpdate = true;
                                    });
                                }
                            });

                            resolve(object);
                        },
                        undefined,
                        (error) => {
                            console.error("加载人物模型失败:", error);
                            reject(error);
                        }
                    );
                });
            });
        };

        // 模型数组
        const models = [];

        // 每个场景的模型配置（每个场景1-3个模型）
        const sceneConfigs = [
            // 场景1：四面体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.TetrahedronGeometry(1, 0),
                    color: 0x667eea,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0x667eea,
                    scale: 0.8,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // 场景2：立方体 + 八面体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.BoxGeometry(1.2, 1.2, 1.2),
                    color: 0x764ba2,
                    offset: { x: -1.8, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.OctahedronGeometry(0.9, 0),
                    color: 0xf093fb,
                    offset: { x: 0, y: 0, z: -1 }
                },
                {
                    type: "character",
                    color: 0x764ba2,
                    scale: 0.9,
                    offset: { x: 1.8, y: 0, z: 0 }
                }
            ],
            // 场景3：二十面体 + 人物 + 球体
            [
                {
                    type: "geometry",
                    geometry: new THREE.IcosahedronGeometry(1, 0),
                    color: 0x4facfe,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0x4facfe,
                    scale: 1,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.SphereGeometry(0.8, 16, 16),
                    color: 0x00d4ff,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // 场景4：多个几何体 + 人物
            [
                {
                    type: "geometry",
                    geometry: new THREE.TorusGeometry(0.8, 0.3, 8, 16),
                    color: 0xff6b9d,
                    offset: { x: -2, y: 0, z: 0 }
                },
                {
                    type: "character",
                    color: 0xff6b9d,
                    scale: 1.1,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.ConeGeometry(0.9, 1.5, 8),
                    color: 0xffa500,
                    offset: { x: 2, y: 0, z: 0 }
                }
            ]
        ];

        // 创建所有模型
        const initModels = async () => {
            for (let sceneIndex = 0; sceneIndex < sceneConfigs.length; sceneIndex++) {
                const sceneModels = sceneConfigs[sceneIndex];
                for (let modelIndex = 0; modelIndex < sceneModels.length; modelIndex++) {
                    const config = sceneModels[modelIndex];
                    let mesh;

                    if (config.type === "character") {
                        try {
                            // 异步加载人物模型
                            mesh = await loadCharacterModel(config.scale);
                            // 标记为人物，保留 config 里的颜色属性（虽然模型自带材质，但为了兼容逻辑）
                            mesh.userData.isCharacter = true;
                        } catch (e) {
                            console.error("Failed to load character:", e);
                            continue;
                        }
                    } else {
                        const material = new THREE.MeshStandardMaterial({
                            color: config.color,
                            metalness: 0.7,
                            roughness: 0.3,
                            emissive: config.color,
                            emissiveIntensity: 0.2
                        });
                        mesh = new THREE.Mesh(config.geometry, material);
                    }

                    mesh.userData = {
                        ...mesh.userData, // 保留加载时可能设置的 userData
                        sceneIndex: sceneIndex,
                        modelIndex: modelIndex,
                        initialScale: 0.01, // 初始极小
                        targetScale: config.type === "character" ? mesh.scale.x : 1, // 如果是人物，目标大小就是加载后设定的大小
                        rotationSpeedX: 0.01 + sceneIndex * 0.003 + modelIndex * 0.001,
                        rotationSpeedY: 0.012 + sceneIndex * 0.004 + modelIndex * 0.001,
                        rotationSpeedZ: 0.008 + sceneIndex * 0.002 + modelIndex * 0.001,
                        offset: config.offset || { x: 0, y: 0, z: 0 },
                        isCharacter: config.type === "character",
                        animationTime: 0
                    };

                    // 初始位置：右上角
                    mesh.position.set(10, 5, 0);
                    // 初始缩放设为很小
                    mesh.scale.set(0.01, 0.01, 0.01);

                    scene.add(mesh);
                    models.push(mesh);
                }
            }
            // 所有模型加载完毕后，手动触发一次更新
            updateModels();
        };

        // 启动加载
        initModels();

        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x667eea, 1, 100);
        pointLight.position.set(-5, 5, 5);
        scene.add(pointLight);

        // 滚动控制
        let scrollProgress = 0;
        const sectionHeight = window.innerHeight;
        const totalSections = 4;

        // 更新模型状态
        const updateModels = () => {
            models.forEach((model) => {
                const sectionStart = model.userData.sceneIndex * sectionHeight;
                const sectionEnd = (model.userData.sceneIndex + 1) * sectionHeight;
                const sectionProgress = (window.scrollY - sectionStart) / sectionHeight;

                // 进入阶段（0-0.3）：从右上角飘到中间
                if (window.scrollY >= sectionStart && window.scrollY < sectionStart + sectionHeight * 0.3) {
                    const enterProgress = Math.min(sectionProgress / 0.3, 1);
                    const easeProgress = 1 - Math.pow(1 - enterProgress, 3); // 缓动函数

                    // 位置：从右上角到中间（加上偏移量）
                    const targetX = model.userData.offset.x;
                    const targetY = model.userData.offset.y;
                    const targetZ = model.userData.offset.z;

                    model.position.x = 10 - (10 - targetX) * easeProgress;
                    model.position.y = 5 - (5 - targetY) * easeProgress;
                    model.position.z = 0 - (0 - targetZ) * easeProgress;

                    // 缩放：从小到大
                    const scale = model.userData.initialScale + (model.userData.targetScale - model.userData.initialScale) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(enterProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 停留阶段（0.3-0.7）：在中间停留并自动旋转，不受滚动影响
                else if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionStart + sectionHeight * 0.7) {
                    // 位置保持在中间（加上偏移量）
                    model.position.x = model.userData.offset.x;
                    model.position.y = model.userData.offset.y;
                    model.position.z = model.userData.offset.z;

                    // 缩放保持目标大小
                    model.scale.set(model.userData.targetScale, model.userData.targetScale, model.userData.targetScale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        // 计算在停留阶段的滚动进度（0-1）
                        const stayProgress = (window.scrollY - (sectionStart + sectionHeight * 0.3)) / (sectionHeight * 0.4);
                        // 使用 sin 函数根据滚动位置实现左右摇摆
                        const swingAngle = Math.sin(stayProgress * Math.PI * 4) * 0.4; // 左右摇摆约23度
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 退出阶段（0.7-1.0）：从中间到左下角消失
                else if (window.scrollY >= sectionStart + sectionHeight * 0.7 && window.scrollY < sectionEnd) {
                    const exitProgress = (sectionProgress - 0.7) / 0.3;
                    const easeProgress = Math.pow(exitProgress, 2); // 缓动函数

                    // 位置：从中间到左下角
                    const startX = model.userData.offset.x;
                    const startY = model.userData.offset.y;
                    const startZ = model.userData.offset.z;

                    model.position.x = startX - (startX - (-10)) * easeProgress;
                    model.position.y = startY - (startY - (-5)) * easeProgress;
                    model.position.z = startZ - (startZ - 5) * easeProgress;

                    // 缩放：从大到小
                    const scale = model.userData.targetScale - (model.userData.targetScale - 0.1) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // 人物模型：根据滚动位置进行左右摇摆
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(exitProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // 其他阶段：隐藏
                else {
                    model.visible = false;
                }
            });
        };

        // 更新文字显示
        const updateTexts = () => {
            const texts = document.querySelectorAll(".text-content");
            texts.forEach((text, index) => {
                const sectionStart = index * sectionHeight;
                const sectionEnd = (index + 1) * sectionHeight;

                if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionEnd) {
                    text.classList.add("visible");
                } else {
                    text.classList.remove("visible");
                }
            });
        };

        // 滚动事件
        let ticking = false;
        const onScroll = () => {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    updateModels();
                    updateTexts();
                    ticking = false;
                });
                ticking = true;
            }
        };

        window.addEventListener("scroll", onScroll);
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始更新
        updateModels();
        updateTexts();


        // 动画循环
        let lastTime = performance.now();
        const animate = (currentTime) => {
            requestAnimationFrame(animate);

            // 确保时间正确计算
            if (!currentTime) {
                currentTime = performance.now();
            }
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // 限制最大deltaTime
            lastTime = currentTime;

            // 如果deltaTime为0或无效，使用固定值
            const validDeltaTime = deltaTime > 0 ? deltaTime : 0.016;

            // 持续旋转所有可见的模型（3D无序旋转）
            models.forEach((model) => {
                if (model.visible) {
                    // 检查模型是否在停留阶段（中间位置）
                    const sectionStart = model.userData.sceneIndex * sectionHeight;
                    const isInCenter = window.scrollY >= sectionStart + sectionHeight * 0.3 &&
                        window.scrollY < sectionStart + sectionHeight * 0.7;

                    if (!model.userData.isCharacter) {
                        // 几何体模型：进行3D无序旋转
                        if (isInCenter) {
                            // 在中间时，进行3D无序旋转
                            model.rotation.x += model.userData.rotationSpeedX;
                            model.rotation.y += model.userData.rotationSpeedY;
                            model.rotation.z += model.userData.rotationSpeedZ;
                        } else {
                            // 其他阶段也保持旋转，但速度稍慢
                            model.rotation.x += model.userData.rotationSpeedX * 0.5;
                            model.rotation.y += model.userData.rotationSpeedY * 0.5;
                            model.rotation.z += model.userData.rotationSpeedZ * 0.5;
                        }
                    }
                }
            });

            renderer.render(scene, camera);
        };

        animate(0);
    </script>
</body>

</html>