<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ»šåŠ¨3Dæ¨¡å‹è§†å·®åŠ¨ç”»</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Arial", sans-serif;
            overflow-x: hidden;
            background: #0a0a0a;
        }

        /* 3D åœºæ™¯å®¹å™¨ */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }

        /* å†…å®¹åŒºåŸŸ */
        .content-section {
            position: relative;
            z-index: 2;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 100px 20px;
            color: #fff;
        }

        .text-content {
            max-width: 800px;
            text-align: center;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s ease, transform 1s ease;
        }

        .text-content.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .text-content h1 {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .text-content h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #81d4fa;
        }

        .text-content p {
            font-size: 1.2rem;
            line-height: 1.8;
            color: #b0bec5;
            margin-bottom: 15px;
        }

        /* æ»šåŠ¨æç¤º */
        .scroll-hint {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .text-content h1 {
                font-size: 2rem;
            }

            .text-content h2 {
                font-size: 1.5rem;
            }

            .text-content p {
                font-size: 1rem;
            }
        }

        /* å…‰æºæ§åˆ¶é¢æ¿ */
        .light-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 12px;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-controls h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #81d4fa;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }

        .light-control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .light-control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .light-control-group h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #b0bec5;
        }

        .light-control-item {
            margin-bottom: 8px;
        }

        .light-control-item label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
            color: #90a4ae;
            font-size: 11px;
        }

        .light-control-item .value {
            color: #fff;
            font-weight: bold;
            min-width: 45px;
            text-align: right;
        }

        .light-control-item input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }

        .light-control-item input[type="number"] {
            width: 60px;
            padding: 3px 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            color: #fff;
            font-size: 11px;
        }

        .position-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .position-controls input {
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div class="content-section" id="section1">
        <div class="text-content" id="text1">
            <h1>æ¢ç´¢æ— é™å¯èƒ½</h1>
            <p>åœ¨æ•°å­—ä¸–ç•Œä¸­ï¼Œæ¯ä¸€ä¸ªåƒç´ éƒ½æ‰¿è½½ç€æ— é™åˆ›æ„</p>
        </div>
    </div>

    <div class="content-section" id="section2">
        <div class="text-content" id="text2">
            <h2>åˆ›æ–°è®¾è®¡</h2>
            <p>å°†æƒ³è±¡åŠ›è½¬åŒ–ä¸ºç°å®ï¼Œç”¨æŠ€æœ¯ç‚¹äº®æœªæ¥</p>
        </div>
    </div>

    <div class="content-section" id="section3">
        <div class="text-content" id="text3">
            <h2>æè‡´ä½“éªŒ</h2>
            <p>æ¯ä¸€ä¸ªç»†èŠ‚éƒ½ç»è¿‡ç²¾å¿ƒæ‰“ç£¨ï¼Œè¿½æ±‚å®Œç¾çš„ç”¨æˆ·ä½“éªŒ</p>
        </div>
    </div>

    <div class="content-section" id="section4">
        <div class="text-content" id="text4">
            <h2>æŒç»­è¿›åŒ–</h2>
            <p>åœ¨ä¸æ–­çš„å­¦ä¹ ä¸å®è·µä¸­ï¼Œåˆ›é€ æ›´ç¾å¥½çš„æ•°å­—ä¸–ç•Œ</p>
        </div>
    </div>

    <div class="scroll-hint">å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤š</div>

    <!-- å…‰æºæ§åˆ¶é¢æ¿ -->
    <div class="light-controls">
        <h3>ğŸ’¡ å…‰æºè®¾ç½®</h3>
        
        <!-- ç¯å¢ƒå…‰ -->
        <div class="light-control-group">
            <h4>ç¯å¢ƒå…‰ (Ambient Light)</h4>
            <div class="light-control-item">
                <label>å¼ºåº¦: <span class="value" id="ambientIntensity">0.5</span></label>
                <input type="range" id="ambientLight" min="0" max="3" step="0.1" value="0.5">
            </div>
        </div>

        <!-- æ–¹å‘å…‰ -->
        <div class="light-control-group">
            <h4>æ–¹å‘å…‰ (Directional Light)</h4>
            <div class="light-control-item">
                <label>å¼ºåº¦: <span class="value" id="directionalIntensity">0.8</span></label>
                <input type="range" id="directionalLight" min="0" max="3" step="0.1" value="0.8">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® X: <span class="value" id="dirPosX">5</span></label>
                <input type="range" id="directionalX" min="-10" max="10" step="0.5" value="5">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Y: <span class="value" id="dirPosY">10</span></label>
                <input type="range" id="directionalY" min="-10" max="10" step="0.5" value="10">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Z: <span class="value" id="dirPosZ">7</span></label>
                <input type="range" id="directionalZ" min="-10" max="10" step="0.5" value="7">
            </div>
        </div>

        <!-- ç‚¹å…‰æº1 -->
        <div class="light-control-group">
            <h4>ç‚¹å…‰æº 1 (Point Light 1)</h4>
            <div class="light-control-item">
                <label>å¼ºåº¦: <span class="value" id="pointIntensity1">1.0</span></label>
                <input type="range" id="pointLight1" min="0" max="3" step="0.1" value="1.0">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® X: <span class="value" id="point1PosX">-5</span></label>
                <input type="range" id="point1X" min="-10" max="10" step="0.5" value="-5">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Y: <span class="value" id="point1PosY">5</span></label>
                <input type="range" id="point1Y" min="-10" max="10" step="0.5" value="5">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Z: <span class="value" id="point1PosZ">5</span></label>
                <input type="range" id="point1Z" min="-10" max="10" step="0.5" value="5">
            </div>
        </div>

        <!-- é¢å¤–ç‚¹å…‰æº2 -->
        <div class="light-control-group">
            <h4>ç‚¹å…‰æº 2 (Point Light 2)</h4>
            <div class="light-control-item">
                <label>å¼ºåº¦: <span class="value" id="pointIntensity2">1.0</span></label>
                <input type="range" id="pointLight2" min="0" max="3" step="0.1" value="1.0">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® X: <span class="value" id="point2PosX">5</span></label>
                <input type="range" id="point2X" min="-10" max="10" step="0.5" value="5">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Y: <span class="value" id="point2PosY">5</span></label>
                <input type="range" id="point2Y" min="-10" max="10" step="0.5" value="5">
            </div>
            <div class="light-control-item">
                <label>ä½ç½® Z: <span class="value" id="point2PosZ">-5</span></label>
                <input type="range" id="point2Z" min="-10" max="10" step="0.5" value="-5">
            </div>
        </div>
    </div>

    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
          }
        }
      </script>


    <script type="module">
        import * as THREE from "three";
        import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
        import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
        import { TGALoader } from "three/addons/loaders/TGALoader.js";

        // æ·»åŠ  TGA Loader æ”¯æŒï¼ˆä½¿ç”¨ DefaultLoadingManagerï¼‰
        const tgaLoader = new TGALoader(THREE.DefaultLoadingManager);
        
        // ä¸º MTL æè´¨åŠ è½½å™¨è®¾ç½® TGA çº¹ç†åŠ è½½å™¨
        // åœ¨ Three.js r160+ ä¸­ï¼Œéœ€è¦é€šè¿‡ LoadingManager å¤„ç†
        THREE.DefaultLoadingManager.addHandler(/\.tga$/i, tgaLoader);

        // åœºæ™¯è®¾ç½®
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById("canvas-container").appendChild(renderer.domElement);

        // ç›¸æœºåˆå§‹ä½ç½®
        camera.position.z = 5;

        // åŠ è½½çœŸå®äººç‰©æ¨¡å‹
        const loadCharacterModel = async (scale = 1) => {
            return new Promise((resolve, reject) => {
                const modelPath = "../../../3DåŠ¨ç”»/module/rem/";

                const mtlLoader = new MTLLoader();
                mtlLoader.setPath(modelPath);

                mtlLoader.load(
                    "untitled.mtl",
                    (materials) => {
                        materials.preload();
                        const objLoader = new OBJLoader();
                        objLoader.setMaterials(materials);
                        objLoader.setPath(modelPath);
                        objLoader.load(
                            "untitled.obj",
                            (object) => {
                                // è°ƒæ•´æ¨¡å‹ä½ç½®å’Œç¼©æ”¾
                                object.scale.set(scale, scale, scale);
                                object.position.set(0, 0, 0);

                                // å­˜å‚¨ä¸ºäººç‰©æ¨¡å‹æ ‡è¯†
                                object.userData.isCharacter = true;

                                resolve(object);
                            },
                            undefined,
                            (error) => {
                                console.error("åŠ è½½äººç‰©æ¨¡å‹å¤±è´¥:", error);
                                reject(error);
                            }
                        );
                    },
                    undefined,
                    (error) => {
                        console.error("åŠ è½½æè´¨å¤±è´¥:", error);
                        reject(error);
                    }
                );
            });
        };

        // æ¨¡å‹æ•°ç»„
        const models = [];

        // æ¯ä¸ªåœºæ™¯çš„æ¨¡å‹é…ç½®ï¼ˆæ¯ä¸ªåœºæ™¯1-3ä¸ªæ¨¡å‹ï¼‰
        const sceneConfigs = [
            // åœºæ™¯1ï¼šå››é¢ä½“ + äººç‰©
            [
                {
                    type: "geometry",
                    geometry: new THREE.TetrahedronGeometry(1, 0),
                    color: 0x667eea,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    scale: 0.15,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // åœºæ™¯2ï¼šç«‹æ–¹ä½“ + å…«é¢ä½“ + äººç‰©
            [
                {
                    type: "geometry",
                    geometry: new THREE.BoxGeometry(1.2, 1.2, 1.2),
                    color: 0x764ba2,
                    offset: { x: -1.8, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.OctahedronGeometry(0.9, 0),
                    color: 0xf093fb,
                    offset: { x: 0, y: 0, z: -1 }
                },
                {
                    type: "character",
                    scale: 0.17,
                    offset: { x: 1.8, y: 0, z: 0 }
                }
            ],
            // åœºæ™¯3ï¼šäºŒåé¢ä½“ + äººç‰© + çƒä½“
            [
                {
                    type: "geometry",
                    geometry: new THREE.IcosahedronGeometry(1, 0),
                    color: 0x4facfe,
                    offset: { x: -1.5, y: 0, z: 0 }
                },
                {
                    type: "character",
                    scale: 0.2,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.SphereGeometry(0.8, 16, 16),
                    color: 0x00d4ff,
                    offset: { x: 1.5, y: 0, z: 0 }
                }
            ],
            // åœºæ™¯4ï¼šå¤šä¸ªå‡ ä½•ä½“ + äººç‰©
            [
                {
                    type: "geometry",
                    geometry: new THREE.TorusGeometry(0.8, 0.3, 8, 16),
                    color: 0xff6b9d,
                    offset: { x: -2, y: 0, z: 0 }
                },
                {
                    type: "character",
                    scale: 0.22,
                    offset: { x: 0, y: 0, z: 0 }
                },
                {
                    type: "geometry",
                    geometry: new THREE.ConeGeometry(0.9, 1.5, 8),
                    color: 0xffa500,
                    offset: { x: 2, y: 0, z: 0 }
                }
            ]
        ];

        // åˆ›å»ºæ‰€æœ‰æ¨¡å‹ï¼ˆå¼‚æ­¥åŠ è½½äººç‰©æ¨¡å‹ï¼‰
        const initModels = async () => {
            // å…ˆåˆ›å»ºå‡ ä½•ä½“æ¨¡å‹
            sceneConfigs.forEach((sceneModels, sceneIndex) => {
                sceneModels.forEach((config, modelIndex) => {
                    if (config.type !== "character") {
                        const material = new THREE.MeshStandardMaterial({
                            color: config.color,
                            metalness: 0.7,
                            roughness: 0.3,
                            emissive: config.color,
                            emissiveIntensity: 0.2
                        });
                        const mesh = new THREE.Mesh(config.geometry, material);

                        mesh.userData = {
                            sceneIndex: sceneIndex,
                            modelIndex: modelIndex,
                            initialScale: 0.1,
                            targetScale: 1,
                            rotationSpeedX: 0.01 + sceneIndex * 0.003 + modelIndex * 0.001,
                            rotationSpeedY: 0.012 + sceneIndex * 0.004 + modelIndex * 0.001,
                            rotationSpeedZ: 0.008 + sceneIndex * 0.002 + modelIndex * 0.001,
                            offset: config.offset || { x: 0, y: 0, z: 0 },
                            isCharacter: false,
                            animationTime: 0
                        };

                        // åˆå§‹ä½ç½®ï¼šå³ä¸Šè§’
                        mesh.position.set(10, 5, 0);
                        mesh.scale.set(0.1, 0.1, 0.1);
                        scene.add(mesh);
                        models.push(mesh);
                    }
                });
            });

            // å¼‚æ­¥åŠ è½½æ‰€æœ‰äººç‰©æ¨¡å‹
            const characterPromises = [];
            sceneConfigs.forEach((sceneModels, sceneIndex) => {
                sceneModels.forEach((config, modelIndex) => {
                    if (config.type === "character") {
                        characterPromises.push(
                            loadCharacterModel(config.scale).then((character) => {
                                character.userData = {
                                    sceneIndex: sceneIndex,
                                    modelIndex: modelIndex,
                                    initialScale: 0.1,
                                    targetScale: 1,
                                    rotationSpeedX: 0.01 + sceneIndex * 0.003 + modelIndex * 0.001,
                                    rotationSpeedY: 0.012 + sceneIndex * 0.004 + modelIndex * 0.001,
                                    rotationSpeedZ: 0.008 + sceneIndex * 0.002 + modelIndex * 0.001,
                                    offset: config.offset || { x: 0, y: 0, z: 0 },
                                    isCharacter: true,
                                    animationTime: 0
                                };

                                // åˆå§‹ä½ç½®ï¼šå³ä¸Šè§’
                                character.position.set(10, 5, 0);
                                character.scale.set(0.1, 0.1, 0.1);
                                scene.add(character);
                                models.push(character);
                            })
                        );
                    }
                });
            });

            // ç­‰å¾…æ‰€æœ‰äººç‰©æ¨¡å‹åŠ è½½å®Œæˆ
            await Promise.all(characterPromises);
        };

        // æ·»åŠ å…‰æºï¼ˆå‚è€ƒ 3D_people_demo.htmlï¼‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        const pointLight1 = new THREE.PointLight(0xffffff, 1.0, 100);
        pointLight1.position.set(-5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.0, 100);
        pointLight2.position.set(5, 5, -5);
        scene.add(pointLight2);

        // å…‰æºæ§åˆ¶
        // ç¯å¢ƒå…‰
        document.getElementById("ambientLight").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            ambientLight.intensity = value;
            document.getElementById("ambientIntensity").textContent = value.toFixed(1);
        });

        // æ–¹å‘å…‰
        document.getElementById("directionalLight").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            directionalLight.intensity = value;
            document.getElementById("directionalIntensity").textContent = value.toFixed(1);
        });

        document.getElementById("directionalX").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            directionalLight.position.x = value;
            document.getElementById("dirPosX").textContent = value.toFixed(1);
        });

        document.getElementById("directionalY").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            directionalLight.position.y = value;
            document.getElementById("dirPosY").textContent = value.toFixed(1);
        });

        document.getElementById("directionalZ").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            directionalLight.position.z = value;
            document.getElementById("dirPosZ").textContent = value.toFixed(1);
        });

        // ç‚¹å…‰æº1
        document.getElementById("pointLight1").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight1.intensity = value;
            document.getElementById("pointIntensity1").textContent = value.toFixed(1);
        });

        document.getElementById("point1X").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight1.position.x = value;
            document.getElementById("point1PosX").textContent = value.toFixed(1);
        });

        document.getElementById("point1Y").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight1.position.y = value;
            document.getElementById("point1PosY").textContent = value.toFixed(1);
        });

        document.getElementById("point1Z").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight1.position.z = value;
            document.getElementById("point1PosZ").textContent = value.toFixed(1);
        });

        // ç‚¹å…‰æº2
        document.getElementById("pointLight2").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight2.intensity = value;
            document.getElementById("pointIntensity2").textContent = value.toFixed(1);
        });

        document.getElementById("point2X").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight2.position.x = value;
            document.getElementById("point2PosX").textContent = value.toFixed(1);
        });

        document.getElementById("point2Y").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight2.position.y = value;
            document.getElementById("point2PosY").textContent = value.toFixed(1);
        });

        document.getElementById("point2Z").addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            pointLight2.position.z = value;
            document.getElementById("point2PosZ").textContent = value.toFixed(1);
        });

        // æ»šåŠ¨æ§åˆ¶
        let scrollProgress = 0;
        const sectionHeight = window.innerHeight;
        const totalSections = 4;

        // æ›´æ–°æ¨¡å‹çŠ¶æ€
        const updateModels = () => {
            models.forEach((model) => {
                const sectionStart = model.userData.sceneIndex * sectionHeight;
                const sectionEnd = (model.userData.sceneIndex + 1) * sectionHeight;
                const sectionProgress = (window.scrollY - sectionStart) / sectionHeight;

                // è¿›å…¥é˜¶æ®µï¼ˆ0-0.3ï¼‰ï¼šä»å³ä¸Šè§’é£˜åˆ°ä¸­é—´
                if (window.scrollY >= sectionStart && window.scrollY < sectionStart + sectionHeight * 0.3) {
                    const enterProgress = Math.min(sectionProgress / 0.3, 1);
                    const easeProgress = 1 - Math.pow(1 - enterProgress, 3); // ç¼“åŠ¨å‡½æ•°

                    // ä½ç½®ï¼šä»å³ä¸Šè§’åˆ°ä¸­é—´ï¼ˆåŠ ä¸Šåç§»é‡ï¼‰
                    const targetX = model.userData.offset.x;
                    const targetY = model.userData.offset.y;
                    const targetZ = model.userData.offset.z;

                    model.position.x = 10 - (10 - targetX) * easeProgress;
                    model.position.y = 5 - (5 - targetY) * easeProgress;
                    model.position.z = 0 - (0 - targetZ) * easeProgress;

                    // ç¼©æ”¾ï¼šä»å°åˆ°å¤§
                    const scale = model.userData.initialScale + (model.userData.targetScale - model.userData.initialScale) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // äººç‰©æ¨¡å‹ï¼šæ ¹æ®æ»šåŠ¨ä½ç½®è¿›è¡Œå·¦å³æ‘‡æ‘†
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(enterProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // åœç•™é˜¶æ®µï¼ˆ0.3-0.7ï¼‰ï¼šåœ¨ä¸­é—´åœç•™å¹¶è‡ªåŠ¨æ—‹è½¬ï¼Œä¸å—æ»šåŠ¨å½±å“
                else if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionStart + sectionHeight * 0.7) {
                    // ä½ç½®ä¿æŒåœ¨ä¸­é—´ï¼ˆåŠ ä¸Šåç§»é‡ï¼‰
                    model.position.x = model.userData.offset.x;
                    model.position.y = model.userData.offset.y;
                    model.position.z = model.userData.offset.z;

                    // ç¼©æ”¾ä¿æŒç›®æ ‡å¤§å°
                    model.scale.set(model.userData.targetScale, model.userData.targetScale, model.userData.targetScale);

                    // äººç‰©æ¨¡å‹ï¼šæ ¹æ®æ»šåŠ¨ä½ç½®è¿›è¡Œå·¦å³æ‘‡æ‘†
                    if (model.userData.isCharacter) {
                        // è®¡ç®—åœ¨åœç•™é˜¶æ®µçš„æ»šåŠ¨è¿›åº¦ï¼ˆ0-1ï¼‰
                        const stayProgress = (window.scrollY - (sectionStart + sectionHeight * 0.3)) / (sectionHeight * 0.4);
                        // ä½¿ç”¨ sin å‡½æ•°æ ¹æ®æ»šåŠ¨ä½ç½®å®ç°å·¦å³æ‘‡æ‘†
                        const swingAngle = Math.sin(stayProgress * Math.PI * 4) * 0.4; // å·¦å³æ‘‡æ‘†çº¦23åº¦
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // é€€å‡ºé˜¶æ®µï¼ˆ0.7-1.0ï¼‰ï¼šä»ä¸­é—´åˆ°å·¦ä¸‹è§’æ¶ˆå¤±
                else if (window.scrollY >= sectionStart + sectionHeight * 0.7 && window.scrollY < sectionEnd) {
                    const exitProgress = (sectionProgress - 0.7) / 0.3;
                    const easeProgress = Math.pow(exitProgress, 2); // ç¼“åŠ¨å‡½æ•°

                    // ä½ç½®ï¼šä»ä¸­é—´åˆ°å·¦ä¸‹è§’
                    const startX = model.userData.offset.x;
                    const startY = model.userData.offset.y;
                    const startZ = model.userData.offset.z;

                    model.position.x = startX - (startX - (-10)) * easeProgress;
                    model.position.y = startY - (startY - (-5)) * easeProgress;
                    model.position.z = startZ - (startZ - 5) * easeProgress;

                    // ç¼©æ”¾ï¼šä»å¤§åˆ°å°
                    const scale = model.userData.targetScale - (model.userData.targetScale - 0.1) * easeProgress;
                    model.scale.set(scale, scale, scale);

                    // äººç‰©æ¨¡å‹ï¼šæ ¹æ®æ»šåŠ¨ä½ç½®è¿›è¡Œå·¦å³æ‘‡æ‘†
                    if (model.userData.isCharacter) {
                        const swingAngle = Math.sin(exitProgress * Math.PI * 4) * 0.4;
                        model.rotation.y = swingAngle;
                        model.rotation.x = 0;
                        model.rotation.z = 0;
                    }

                    model.visible = true;
                }
                // å…¶ä»–é˜¶æ®µï¼šéšè—
                else {
                    model.visible = false;
                }
            });
        };

        // æ›´æ–°æ–‡å­—æ˜¾ç¤º
        const updateTexts = () => {
            const texts = document.querySelectorAll(".text-content");
            texts.forEach((text, index) => {
                const sectionStart = index * sectionHeight;
                const sectionEnd = (index + 1) * sectionHeight;

                if (window.scrollY >= sectionStart + sectionHeight * 0.3 && window.scrollY < sectionEnd) {
                    text.classList.add("visible");
                } else {
                    text.classList.remove("visible");
                }
            });
        };

        // æ»šåŠ¨äº‹ä»¶
        let ticking = false;
        const onScroll = () => {
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    updateModels();
                    updateTexts();
                    ticking = false;
                });
                ticking = true;
            }
        };

        window.addEventListener("scroll", onScroll);
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆåè¿›è¡Œåˆå§‹æ›´æ–°
        initModels().then(() => {
            updateModels();
            updateTexts();
        }).catch((error) => {
            console.error("åˆå§‹åŒ–æ¨¡å‹å¤±è´¥:", error);
            // å³ä½¿åŠ è½½å¤±è´¥ä¹Ÿæ‰§è¡Œæ›´æ–°ï¼Œè‡³å°‘å‡ ä½•ä½“æ¨¡å‹å¯ä»¥æ˜¾ç¤º
            updateModels();
            updateTexts();
        });


        // åŠ¨ç”»å¾ªç¯
        let lastTime = performance.now();
        const animate = (currentTime) => {
            requestAnimationFrame(animate);

            // ç¡®ä¿æ—¶é—´æ­£ç¡®è®¡ç®—
            if (!currentTime) {
                currentTime = performance.now();
            }
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // é™åˆ¶æœ€å¤§deltaTime
            lastTime = currentTime;

            // å¦‚æœdeltaTimeä¸º0æˆ–æ— æ•ˆï¼Œä½¿ç”¨å›ºå®šå€¼
            const validDeltaTime = deltaTime > 0 ? deltaTime : 0.016;

            // æŒç»­æ—‹è½¬æ‰€æœ‰å¯è§çš„æ¨¡å‹ï¼ˆ3Dæ— åºæ—‹è½¬ï¼‰
            models.forEach((model) => {
                if (model.visible) {
                    // æ£€æŸ¥æ¨¡å‹æ˜¯å¦åœ¨åœç•™é˜¶æ®µï¼ˆä¸­é—´ä½ç½®ï¼‰
                    const sectionStart = model.userData.sceneIndex * sectionHeight;
                    const isInCenter = window.scrollY >= sectionStart + sectionHeight * 0.3 &&
                        window.scrollY < sectionStart + sectionHeight * 0.7;

                    if (!model.userData.isCharacter) {
                        // å‡ ä½•ä½“æ¨¡å‹ï¼šè¿›è¡Œ3Dæ— åºæ—‹è½¬
                        if (isInCenter) {
                            // åœ¨ä¸­é—´æ—¶ï¼Œè¿›è¡Œ3Dæ— åºæ—‹è½¬
                            model.rotation.x += model.userData.rotationSpeedX;
                            model.rotation.y += model.userData.rotationSpeedY;
                            model.rotation.z += model.userData.rotationSpeedZ;
                        } else {
                            // å…¶ä»–é˜¶æ®µä¹Ÿä¿æŒæ—‹è½¬ï¼Œä½†é€Ÿåº¦ç¨æ…¢
                            model.rotation.x += model.userData.rotationSpeedX * 0.5;
                            model.rotation.y += model.userData.rotationSpeedY * 0.5;
                            model.rotation.z += model.userData.rotationSpeedZ * 0.5;
                        }
                    }
                }
            });

            renderer.render(scene, camera);
        };

        animate(0);
    </script>
</body>

</html>