<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>FLIP 动画原理演示</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 50px; background: #f0f2f5; }
        .list { width: 300px; display: flex; flex-direction: column; gap: 10px; }
        .item {
            background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none;
        }
        .btn { margin-bottom: 20px; padding: 10px 20px; cursor: pointer; background: #333; color: white; border: none; border-radius: 4px; }
        .interview-box { width: 600px; margin-top: 50px; background: white; padding: 20px; border-radius: 8px; }
    </style>
</head>
<body>

    <button class="btn" onclick="shuffleList()">随机乱序 (应用 FLIP 动画)</button>

    <div class="list" id="list">
        <div class="item" id="item-1">Item 1</div>
        <div class="item" id="item-2">Item 2</div>
        <div class="item" id="item-3">Item 3</div>
        <div class="item" id="item-4">Item 4</div>
        <div class="item" id="item-5">Item 5</div>
    </div>

    <script>
        const list = document.getElementById('list');

        function shuffleList() {
            const items = Array.from(list.children);

            // ==========================================
            // FLIP 核心四步曲
            // ==========================================

            // 1. First: 记录初始位置
            const firstPositions = new Map();
            items.forEach(item => {
                firstPositions.set(item, item.getBoundingClientRect());
            });

            // 2. Last: 执行 DOM 操作（改变布局）
            // 这里我们随机打乱顺序并重新插入 DOM
            const shuffled = items.sort(() => Math.random() - 0.5);
            shuffled.forEach(item => list.appendChild(item));

            // 3. Invert: 计算位置差并应用反向变换
            items.forEach(item => {
                const first = firstPositions.get(item);
                const last = item.getBoundingClientRect(); // 获取新位置

                // 计算差值
                const deltaX = first.left - last.left;
                const deltaY = first.top - last.top;

                // 瞬间将元素通过 transform 移动回初始视觉位置
                // 这一步必须没有动画（transition: none）
                if (deltaX !== 0 || deltaY !== 0) {
                    item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    item.style.transition = 'none';
                }
            });

            // 4. Play: 启用过渡并移除 transform
            // 强制浏览器重排 (Reflow) 以应用上一帧的 transform
            // requestAnimationFrame 的双重调用或 document.body.offsetHeight 都可以触发
            requestAnimationFrame(() => {
                items.forEach(item => {
                    item.style.transition = 'transform 0.5s cubic-bezier(0.2, 0, 0.2, 1)';
                    item.style.transform = ''; // 移除 transform，元素会动画移动到 Last 位置
                });
            });
        }
    </script>

    <div class="interview-box">
        <h3>面试考察点：</h3>
        <p><strong>1. 什么是 FLIP 动画技术？解释一下这四个字母代表什么？</strong></p>
        <!-- 
            答案：
            FLIP 是一种实现高性能布局动画的方法论，由 Google 提出。
            - First: 记录元素在动画开始前的初始状态（位置、大小等）。
            - Last: 执行布局变更（如 DOM 排序、增删），记录元素的最终状态。
            - Invert: 计算 First 和 Last 的差值，使用 transform 将元素“反向”平移回初始视觉位置。这让元素看起来好像还在原地。
            - Play: 启用 transition，移除 transform，让元素从“假”的初始位置平滑过渡到“真”的最终位置。
        -->

        <p><strong>2. 为什么要用 FLIP？直接给元素加 transition: all 不行吗？</strong></p>
        <!-- 
            答案：
            直接加 transition: all 在很多场景下无效或性能差：
            1. 布局突变：如果是 DOM 节点顺序改变（如 appendChild 移动节点），浏览器会直接重排，无法自动生成补间动画。
            2. 性能问题：如果用 absolute 定位并改变 top/left，会触发 Layout（重排），性能消耗大。
            3. FLIP 的优势：整个动画过程只改变 transform 和 opacity，只触发 Composite（合成），由 GPU 处理，能保证 60FPS 流畅度。
        -->

        <p><strong>3. 代码中 Invert 阶段为什么要先 `transition: none`？</strong></p>
        <!-- 
            答案：
            Invert 的目的是瞬间将元素“瞬移”回视觉起点。
            如果此时有 transition，元素会慢慢飞回去，导致闪烁或动画逻辑错误。
            必须关闭过渡，瞬间应用 transform，然后再在 Play 阶段开启过渡。
        -->
    </div>
</body>
</html>
