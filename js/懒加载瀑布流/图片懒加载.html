<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>ä¼˜åŒ–ç‰ˆå›¾ç‰‡æ‡’åŠ è½½</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f7fa;
      line-height: 1.6;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .wrap h3 {
      text-align: center;
      font-size: 2rem;
      color: #2c3e50;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      background: #667eea;
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .stats {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
      display: flex;
      justify-content: space-around;
      text-align: center;
      flex-wrap: wrap;
      gap: 20px;
    }

    .stat-item {
      flex: 1;
      min-width: 100px;
    }

    .stat-number {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
      display: block;
    }

    .stat-label {
      color: #6c757d;
      font-size: 0.9rem;
      margin-top: 5px;
    }

    .con {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }

    .image-container {
      position: relative;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .image-container:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    }

    .con img {
      width: 100%;
      height: 250px;
      object-fit: cover;
      display: block;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .con img.loaded {
      opacity: 1;
    }

    .con img.error {
      opacity: 0.5;
    }

    /* éª¨æ¶å±æ ·å¼ */
    .skeleton {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          #f0f0f0 25%,
          #e0e0e0 37%,
          #f0f0f0 63%);
      background-size: 400% 100%;
      animation: skeleton-loading 1.4s ease infinite;
      transition: opacity 0.3s ease;
    }

    .skeleton.hide {
      opacity: 0;
      pointer-events: none;
    }

    @keyframes skeleton-loading {
      0% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0 50%;
      }
    }

    /* é”™è¯¯å ä½ç¬¦ */
    .error-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: #f8f9fa;
      color: #6c757d;
      font-size: 0.9rem;
    }

    .error-icon {
      font-size: 2rem;
      margin-bottom: 10px;
      opacity: 0.5;
    }

    /* åŠ è½½çŠ¶æ€æŒ‡ç¤º */
    .loading-indicator {
      position: absolute;
      bottom: 10px;
      right: 10px;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 15px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .status-loading {
      background: rgba(255, 193, 7, 0.9);
      color: #856404;
    }

    .status-loaded {
      background: rgba(40, 167, 69, 0.9);
      color: white;
    }

    .status-error {
      background: rgba(220, 53, 69, 0.9);
      color: white;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      .wrap {
        padding: 15px;
      }

      .con {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
      }

      .con img {
        height: 200px;
      }

      .stats {
        flex-direction: column;
        gap: 15px;
      }
    }

    @media (max-width: 480px) {
      .con {
        grid-template-columns: 1fr;
      }

      .controls {
        flex-direction: column;
        align-items: center;
      }
    }

    /* æ·±è‰²ä¸»é¢˜æ”¯æŒ */
    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #ffffff;
      }

      .skeleton {
        background: linear-gradient(90deg,
            #2a2a2a 25%,
            #3a3a3a 37%,
            #2a2a2a 63%);
      }

      .image-container {
        background: #2c2c2c;
      }

      .stats {
        background: #2c2c2c;
      }
    }

    /* å‡å°‘åŠ¨ç”»åå¥½æ”¯æŒ */
    @media (prefers-reduced-motion: reduce) {
      .skeleton {
        animation: none;
        background: #e0e0e0;
      }

      .con img {
        transition: none;
      }

      .image-container {
        transition: none;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h3>ğŸš€ ä¼˜åŒ–ç‰ˆå›¾ç‰‡æ‡’åŠ è½½æ¼”ç¤º</h3>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="controls">
      <button class="btn" onclick="loadAllImages()">âš¡ å…¨éƒ¨åŠ è½½</button>
      <button class="btn" onclick="resetDemo()">ğŸ”„ é‡ç½®æ¼”ç¤º</button>
      <button class="btn" onclick="toggleSequential()" id="sequentialBtn">
        ğŸ“‹ é¡ºåºåŠ è½½
      </button>
      <button class="btn" onclick="toggleKeepObserving()" id="keepObservingBtn">
        ğŸ‘ï¸ ä¿æŒè§‚å¯Ÿ
      </button>
      <button class="btn" onclick="toggleDebug()">ğŸ› è°ƒè¯•æ¨¡å¼</button>
    </div>

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <div class="stats">
      <div class="stat-item">
        <span class="stat-number" id="totalImages">0</span>
        <div class="stat-label">æ€»å›¾ç‰‡æ•°</div>
      </div>
      <div class="stat-item">
        <span class="stat-number" id="loadedImages">0</span>
        <div class="stat-label">å·²åŠ è½½</div>
      </div>
      <div class="stat-item">
        <span class="stat-number" id="loadingImages">0</span>
        <div class="stat-label">åŠ è½½ä¸­</div>
      </div>
      <div class="stat-item">
        <span class="stat-number" id="errorImages">0</span>
        <div class="stat-label">åŠ è½½å¤±è´¥</div>
      </div>
      <div class="stat-item">
        <span class="stat-number" id="avgLoadTime">0ms</span>
        <div class="stat-label">å¹³å‡åŠ è½½æ—¶é—´</div>
      </div>
    </div>

    <div class="con" id="imageContainer">
      <!-- åŠ¨æ€ç”Ÿæˆçš„å›¾ç‰‡å®¹å™¨ -->
    </div>
  </div>

  <script>
    /**
     * ç°ä»£åŒ–æ‡’åŠ è½½ç±» - ä¼˜åŒ–ç‰ˆ
     */
    class ModernLazyLoader {
      constructor(options = {}) {
        // é»˜è®¤é…ç½®
        this.options = {
          rootMargin: "50px 0px 100px 0px",
          threshold: 0.01,
          maxConcurrent: 3,
          retryCount: 3, // å¢åŠ é‡è¯•æ¬¡æ•°
          retryDelay: 1000,
          skeletonDuration: 600,
          debug: false,
          sequentialLoad: false, // æ˜¯å¦æŒ‰é¡ºåºåŠ è½½
          keepObserving: true, // ä¿æŒè§‚å¯Ÿï¼Œå³ä½¿åŠ è½½å¤±è´¥ä¹Ÿä¸è§£ç»‘
          ...options,
        };

        // çŠ¶æ€ç®¡ç†
        this.stats = {
          total: 0,
          loaded: 0,
          loading: 0,
          error: 0,
        };

        // æ€§èƒ½ç›‘æ§
        this.performance = {
          loadTimes: [],
          startTime: Date.now(),
        };

        // å†…éƒ¨çŠ¶æ€
        this.loadingQueue = new Set();
        this.retryMap = new Map();
        this.observer = null;
        this.elements = new Set();
        this.pendingElements = []; // å¾…åŠ è½½é˜Ÿåˆ—ï¼ˆç”¨äºé¡ºåºåŠ è½½ï¼‰
        this.currentIndex = 0; // å½“å‰åŠ è½½ç´¢å¼•
        this.visibleElements = new Set(); // å¯è§å…ƒç´ é›†åˆ

        this.init();
      }

      init() {
        this.log("åˆå§‹åŒ–æ‡’åŠ è½½å™¨...");
        this.createObserver();
        this.bindEvents();
        this.log("æ‡’åŠ è½½å™¨åˆå§‹åŒ–å®Œæˆ");
      }

      createObserver() {
        if (!("IntersectionObserver" in window)) {
          this.log("ä¸æ”¯æŒ IntersectionObserverï¼Œé™çº§åˆ°æ»šåŠ¨äº‹ä»¶");
          this.fallbackToScroll();
          return;
        }

        this.observer = new IntersectionObserver(
          (entries) => this.handleIntersection(entries),
          {
            rootMargin: this.options.rootMargin,
            threshold: this.options.threshold,
          }
        );
      }

      handleIntersection(entries) {
        entries.forEach((entry) => {
          const img = entry.target;

          if (entry.isIntersecting) {
            // æ·»åŠ åˆ°å¯è§å…ƒç´ é›†åˆ
            this.visibleElements.add(img);
            this.log("ğŸ“ å›¾ç‰‡è¿›å…¥è§†å£:", img.dataset.src);

            if (this.options.sequentialLoad) {
              // é¡ºåºåŠ è½½æ¨¡å¼
              this.handleSequentialLoad();
            } else {
              // å¹¶å‘åŠ è½½æ¨¡å¼
              this.handleConcurrentLoad(img);
            }
          } else {
            // ç§»å‡ºå¯è§åŒºåŸŸ
            this.visibleElements.delete(img);
          }
        });
      }

      handleConcurrentLoad(img) {
        if (this.loadingQueue.size >= this.options.maxConcurrent) {
          this.log("â³ è¾¾åˆ°å¹¶å‘é™åˆ¶ï¼Œç­‰å¾…ä¸­...", img.dataset.src);
          return;
        }

        this.loadImage(img);

        // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦è§£ç»‘è§‚å¯Ÿ
        if (!this.options.keepObserving) {
          this.observer.unobserve(img);
          this.elements.delete(img);
        }
      }

      handleSequentialLoad() {
        // æŒ‰é¡ºåºåŠ è½½å¯è§çš„å›¾ç‰‡
        const sortedVisible = Array.from(this.visibleElements).sort(
          (a, b) => {
            const aIndex = parseInt(a.dataset.index) || 0;
            const bIndex = parseInt(b.dataset.index) || 0;
            return aIndex - bIndex;
          }
        );

        // æ‰¾åˆ°ä¸‹ä¸€ä¸ªéœ€è¦åŠ è½½çš„å›¾ç‰‡
        for (const img of sortedVisible) {
          if (
            !img.classList.contains("loaded") &&
            !img.classList.contains("error") &&
            !this.loadingQueue.has(img)
          ) {
            if (this.loadingQueue.size < this.options.maxConcurrent) {
              this.loadImage(img);
              break; // ä¸€æ¬¡åªåŠ è½½ä¸€å¼ ï¼ˆä¸¥æ ¼é¡ºåºï¼‰
            }
            break;
          }
        }
      }

      async loadImage(img) {
        const src = img.dataset.src;
        if (!src || this.loadingQueue.has(img)) return;

        this.loadingQueue.add(img);
        this.updateStats("loading", 1);
        this.updateImageStatus(img, "loading");

        const startTime = Date.now();
        const skeleton = img.parentElement.querySelector(".skeleton");

        try {
          // ç¡®ä¿éª¨æ¶å±æ˜¾ç¤ºè¶³å¤Ÿæ—¶é—´
          const [loadResult] = await Promise.all([
            this.preloadImage(src),
            this.delay(this.options.skeletonDuration),
          ]);

          // åŠ è½½æˆåŠŸ
          img.src = src;
          img.classList.add("loaded");

          // éšè—éª¨æ¶å±
          if (skeleton) {
            skeleton.classList.add("hide");
            setTimeout(() => skeleton.remove(), 300);
          }

          this.updateImageStatus(img, "loaded");
          this.updateStats("loading", -1);
          this.updateStats("loaded", 1);

          // è®°å½•æ€§èƒ½æ•°æ®
          const loadTime = Date.now() - startTime;
          this.performance.loadTimes.push(loadTime);

          this.log("âœ… å›¾ç‰‡åŠ è½½æˆåŠŸ:", src, "è€—æ—¶:", loadTime + "ms");

          // å¦‚æœæ˜¯é¡ºåºåŠ è½½æ¨¡å¼ï¼Œç»§ç»­åŠ è½½ä¸‹ä¸€å¼ 
          if (this.options.sequentialLoad) {
            setTimeout(() => this.handleSequentialLoad(), 100);
          } else if (this.options.keepObserving) {
            // å¹¶å‘æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…çš„å›¾ç‰‡
            setTimeout(() => this.checkPendingImages(), 100);
          }
        } catch (error) {
          this.log("âŒ å›¾ç‰‡åŠ è½½å¤±è´¥:", src, error);
          await this.handleImageError(img, src, skeleton, error);
        } finally {
          this.loadingQueue.delete(img);
        }
      }

      preloadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Failed to load: ${src}`));
          setTimeout(() => reject(new Error("Load timeout")), 10000);
          img.src = src;
        });
      }

      async handleImageError(img, src, skeleton, error) {
        const retryCount = this.retryMap.get(img) || 0;

        if (retryCount < this.options.retryCount) {
          this.retryMap.set(img, retryCount + 1);
          await this.delay(this.options.retryDelay * (retryCount + 1));

          try {
            await this.preloadImage(src);
            img.src = src;
            img.classList.add("loaded");
            this.updateImageStatus(img, "loaded");
            this.updateStats("loading", -1);
            this.updateStats("loaded", 1);
            return;
          } catch (retryError) {
            this.log(`é‡è¯• ${retryCount + 1} å¤±è´¥:`, src);
          }
        }

        // æœ€ç»ˆå¤±è´¥å¤„ç†
        this.handleFinalError(img, skeleton);
      }

      checkPendingImages() {
        // æ£€æŸ¥å¯è§åŒºåŸŸå†…æ˜¯å¦è¿˜æœ‰æœªåŠ è½½çš„å›¾ç‰‡
        this.visibleElements.forEach((img) => {
          if (
            !img.classList.contains("loaded") &&
            !img.classList.contains("error") &&
            !this.loadingQueue.has(img) &&
            this.loadingQueue.size < this.options.maxConcurrent
          ) {
            this.log("ğŸ”„ é‡æ–°å°è¯•åŠ è½½:", img.dataset.src);
            this.loadImage(img);
          }
        });
      }

      handleFinalError(img, skeleton) {
        const errorPlaceholder = document.createElement("div");
        errorPlaceholder.className = "error-placeholder";
        errorPlaceholder.innerHTML = `
            <div class="error-icon">ğŸ–¼ï¸</div>
            <div>å›¾ç‰‡åŠ è½½å¤±è´¥</div>
          `;

        img.parentElement.appendChild(errorPlaceholder);

        if (skeleton) {
          skeleton.classList.add("hide");
          setTimeout(() => skeleton.remove(), 300);
        }

        img.classList.add("error");
        this.updateImageStatus(img, "error");
        this.updateStats("loading", -1);
        this.updateStats("error", 1);

        // é”™è¯¯åä¹Ÿè¦æ£€æŸ¥æ˜¯å¦ç»§ç»­åŠ è½½
        if (this.options.sequentialLoad) {
          setTimeout(() => this.handleSequentialLoad(), 100);
        } else if (this.options.keepObserving) {
          setTimeout(() => this.checkPendingImages(), 100);
        }
      }

      updateImageStatus(img, status) {
        const indicator =
          img.parentElement.querySelector(".loading-indicator");
        if (indicator) {
          indicator.className = `loading-indicator status-${status}`;
          indicator.textContent = {
            loading: "åŠ è½½ä¸­...",
            loaded: "å·²åŠ è½½",
            error: "åŠ è½½å¤±è´¥",
          }[status];
        }
      }

      observe(element) {
        if (this.observer && !element.dataset.observed) {
          element.dataset.observed = "true";
          this.observer.observe(element);
          this.elements.add(element);
          this.stats.total++;
          this.updateStatsDisplay();
        }
      }

      updateStats(type, delta) {
        this.stats[type] += delta;
        this.updateStatsDisplay();
      }

      updateStatsDisplay() {
        document.getElementById("totalImages").textContent = this.stats.total;
        document.getElementById("loadedImages").textContent =
          this.stats.loaded;
        document.getElementById("loadingImages").textContent =
          this.stats.loading;
        document.getElementById("errorImages").textContent = this.stats.error;

        const avgTime =
          this.performance.loadTimes.length > 0
            ? Math.round(
              this.performance.loadTimes.reduce((a, b) => a + b, 0) /
              this.performance.loadTimes.length
            )
            : 0;
        document.getElementById("avgLoadTime").textContent = avgTime + "ms";
      }

      bindEvents() {
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            this.pauseLoading = true;
          } else {
            this.pauseLoading = false;
          }
        });
      }

      fallbackToScroll() {
        let ticking = false;

        const checkImages = () => {
          const images = document.querySelectorAll(
            "[data-src]:not(.loaded):not(.error)"
          );
          const scrollTop =
            window.pageYOffset || document.documentElement.scrollTop;
          const windowHeight = window.innerHeight;

          images.forEach((img) => {
            const rect = img.getBoundingClientRect();
            if (rect.top <= windowHeight + 100) {
              this.loadImage(img);
            }
          });

          ticking = false;
        };

        const onScroll = () => {
          if (!ticking) {
            requestAnimationFrame(checkImages);
            ticking = true;
          }
        };

        window.addEventListener("scroll", onScroll);
        checkImages();
      }

      loadAll() {
        this.elements.forEach((element) => {
          if (
            !element.classList.contains("loaded") &&
            !element.classList.contains("error")
          ) {
            this.loadImage(element);
          }
        });
      }

      destroy() {
        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
        this.elements.clear();
        this.loadingQueue.clear();
        this.retryMap.clear();
        this.log("æ‡’åŠ è½½å™¨å·²é”€æ¯");
      }

      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      log(...args) {
        if (this.options.debug) {
          console.log("[LazyLoader]", ...args);
        }
      }
    }

    // å…¨å±€å˜é‡
    let lazyLoader;
    let debugMode = false;
    let sequentialMode = false;
    let keepObservingMode = true;

    // å›¾ç‰‡æ•°æ®
    const imageData = [
      "images/001.jpg",
      "images/002.jpg",
      "images/003.jpg",
      "images/004.jpg",
      "images/005.jpg",
      "images/006.jpg",
      "images/007.jpg",
      "images/008.jpg",
      "images/009.jpg",
      "images/010.jpg",
      "images/011.jpg",
      "images/012.jpg",
      "images/001.jpg",
      "images/002.jpg",
      "images/003.jpg",
      "images/004.jpg",
      "images/005.jpg",
      "images/006.jpg",
      "images/007.jpg",
      "images/008.jpg",
      "images/009.jpg",
      "images/010.jpg",
      "images/011.jpg",
      "images/012.jpg",
      "images/001.jpg",
      "images/002.jpg",
      "images/003.jpg",
      "images/004.jpg",
      "images/005.jpg",
      "images/006.jpg",
      "images/007.jpg",
      "images/008.jpg",
      "images/009.jpg",
      "images/010.jpg",
      "images/011.jpg",
      "images/012.jpg",
    ];

    // åˆå§‹åŒ–
    document.addEventListener("DOMContentLoaded", function () {
      initLazyLoader();
      generateImages();
    });

    function initLazyLoader() {
      lazyLoader = new ModernLazyLoader({
        rootMargin: "50px 0px 100px 0px",
        threshold: 0.01,
        maxConcurrent: 4,
        retryCount: 3,
        retryDelay: 1000,
        skeletonDuration: 600,
        debug: debugMode,
        sequentialLoad: sequentialMode,
        keepObserving: keepObservingMode,
      });
    }

    function generateImages() {
      const container = document.getElementById("imageContainer");
      const fragment = document.createDocumentFragment();

      imageData.forEach((src, index) => {
        const imageContainer = document.createElement("div");
        imageContainer.className = "image-container";
        imageContainer.innerHTML = `
            <div class="skeleton"></div>
            <img data-src="${src}" data-index="${index}" alt="å›¾ç‰‡ ${index + 1
          }" />
            <div class="loading-indicator status-loading">ç­‰å¾…åŠ è½½ #${index + 1
          }</div>
          `;
        fragment.appendChild(imageContainer);
      });

      container.appendChild(fragment);

      // è§‚å¯Ÿæ‰€æœ‰å›¾ç‰‡
      const images = container.querySelectorAll("img[data-src]");
      images.forEach((img) => lazyLoader.observe(img));
    }

    // å…¨å±€å‡½æ•°
    function loadAllImages() {
      lazyLoader.loadAll();
    }

    function resetDemo() {
      const container = document.getElementById("imageContainer");
      container.innerHTML = "";

      lazyLoader.destroy();
      initLazyLoader();
      generateImages();
    }

    function toggleDebug() {
      debugMode = !debugMode;

      lazyLoader.destroy();
      initLazyLoader();

      const images = document.querySelectorAll("img[data-src]");
      images.forEach((img) => {
        if (!img.dataset.observed) {
          lazyLoader.observe(img);
        }
      });

      const btn = event.target;
      btn.textContent = debugMode ? "ğŸ› è°ƒè¯•æ¨¡å¼ (å¼€)" : "ğŸ› è°ƒè¯•æ¨¡å¼";
      btn.style.background = debugMode ? "#28a745" : "#667eea";
    }

    function toggleSequential() {
      sequentialMode = !sequentialMode;

      lazyLoader.destroy();
      initLazyLoader();

      const images = document.querySelectorAll("img[data-src]");
      images.forEach((img) => {
        img.classList.remove("loaded", "error");
        img.src = "";
        lazyLoader.observe(img);
      });

      const btn = document.getElementById("sequentialBtn");
      btn.textContent = sequentialMode ? "ğŸ“‹ é¡ºåºåŠ è½½ (å¼€)" : "ğŸ“‹ é¡ºåºåŠ è½½";
      btn.style.background = sequentialMode ? "#28a745" : "#667eea";

      console.log(
        "ğŸ”„ åˆ‡æ¢åˆ°",
        sequentialMode ? "é¡ºåºåŠ è½½" : "å¹¶å‘åŠ è½½",
        "æ¨¡å¼"
      );
    }

    function toggleKeepObserving() {
      keepObservingMode = !keepObservingMode;

      lazyLoader.destroy();
      initLazyLoader();

      const images = document.querySelectorAll("img[data-src]");
      images.forEach((img) => {
        img.classList.remove("loaded", "error");
        img.src = "";
        lazyLoader.observe(img);
      });

      const btn = document.getElementById("keepObservingBtn");
      btn.textContent = keepObservingMode
        ? "ğŸ‘ï¸ ä¿æŒè§‚å¯Ÿ (å¼€)"
        : "ğŸ‘ï¸ ä¿æŒè§‚å¯Ÿ";
      btn.style.background = keepObservingMode ? "#28a745" : "#667eea";

      console.log(
        "ğŸ”„ åˆ‡æ¢åˆ°",
        keepObservingMode ? "ä¿æŒè§‚å¯Ÿ" : "ä¸€æ¬¡æ€§è§‚å¯Ÿ",
        "æ¨¡å¼"
      );
    }
  </script>
</body>

</html>