<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>üöÄ Áé∞‰ª£ÂåñÁÄëÂ∏ÉÊµÅ - ‰ºòÂåñÁâà</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: #667eea;
            color: white;
            min-width: 80px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn.active {
            background: #28a745;
        }

        .stats {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            margin: 20px auto;
            max-width: 1400px;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-around;
            text-align: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-item {
            flex: 1;
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px 40px;
            position: relative;
        }

        .waterfall {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            grid-auto-rows: 10px;
        }

        .waterfall-item {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .waterfall-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .waterfall-item img {
            width: 100%;
            height: auto;
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .waterfall-item img.loaded {
            opacity: 1;
        }

        .waterfall-item img.error {
            opacity: 0.5;
        }

        /* È™®Êû∂Â±è */
        .skeleton {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(90deg,
                    #f0f0f0 25%,
                    #e0e0e0 37%,
                    #f0f0f0 63%);
            background-size: 400% 100%;
            animation: skeleton-loading 1.4s ease infinite;
            transition: opacity 0.3s ease;
        }

        .skeleton.hide {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes skeleton-loading {
            0% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0 50%;
            }
        }

        /* Âä†ËΩΩÁä∂ÊÄÅÊåáÁ§∫Âô® */
        .loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
            z-index: 10;
        }

        .status-loading {
            background: rgba(255, 193, 7, 0.9);
            color: #856404;
        }

        .status-loaded {
            background: rgba(40, 167, 69, 0.9);
            color: white;
        }

        .status-error {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        /* ÈîôËØØÂç†‰ΩçÁ¨¶ */
        .error-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: #f8f9fa;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .error-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ */
        .load-more {
            text-align: center;
            margin: 40px 0;
        }

        .load-more .btn {
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 25px;
        }

        /* Êó†ÈôêÊªöÂä®Âä†ËΩΩÊåáÁ§∫Âô® */
        .infinite-loading {
            text-align: center;
            padding: 40px;
            font-size: 1.1rem;
            color: white;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 1200px) {
            .waterfall {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .waterfall {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 15px;
            }

            .stats {
                flex-direction: column;
                gap: 15px;
            }

            .container {
                padding: 0 15px 30px;
            }
        }

        @media (max-width: 480px) {
            .waterfall {
                grid-template-columns: 1fr;
            }

            .controls {
                justify-content: center;
                width: 100%;
            }
        }

        /* Ê∑±Ëâ≤‰∏ªÈ¢òÊîØÊåÅ */
        @media (prefers-color-scheme: dark) {
            .skeleton {
                background: linear-gradient(90deg,
                        #2a2a2a 25%,
                        #3a3a3a 37%,
                        #2a2a2a 63%);
            }

            .waterfall-item {
                background: #2c2c2c;
            }

            .error-placeholder {
                background: #1a1a1a;
                color: #ffffff;
            }
        }

        /* ÂáèÂ∞ëÂä®ÁîªÂÅèÂ•ΩÊîØÊåÅ */
        @media (prefers-reduced-motion: reduce) {
            .skeleton {
                animation: none;
                background: #e0e0e0;
            }

            .waterfall-item img {
                transition: none;
            }

            .waterfall-item {
                transition: none;
            }
        }

        /* ÂõæÁâáÈ¢ÑËßàÊ®°ÊÄÅÊ°Ü */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .modal img {
            width: 100%;
            height: auto;
            display: block;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>

<body>
    <!-- Â§¥ÈÉ® -->
    <div class="header">
        <div class="header-content">
            <h1 class="title">üöÄ Áé∞‰ª£ÂåñÁÄëÂ∏ÉÊµÅ</h1>
            <div class="controls">
                <button class="btn" onclick="toggleLazyLoad()" id="lazyBtn">üí§ ÊáíÂä†ËΩΩ</button>
                <button class="btn" onclick="toggleInfiniteScroll()" id="infiniteBtn">‚ôæÔ∏è Êó†ÈôêÊªöÂä®</button>
                <button class="btn" onclick="changeColumns()" id="columnsBtn">üì± ÂìçÂ∫îÂºè</button>
                <button class="btn" onclick="toggleDebug()" id="debugBtn">üêõ Ë∞ÉËØï</button>
                <button class="btn" onclick="resetWaterfall()">üîÑ ÈáçÁΩÆ</button>
            </div>
        </div>
    </div>

    <!-- ÁªüËÆ°Èù¢Êùø -->
    <div class="stats">
        <div class="stat-item">
            <span class="stat-number" id="totalItems">0</span>
            <div class="stat-label">ÊÄªÂõæÁâáÊï∞</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="loadedItems">0</span>
            <div class="stat-label">Â∑≤Âä†ËΩΩ</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="loadingItems">0</span>
            <div class="stat-label">Âä†ËΩΩ‰∏≠</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="errorItems">0</span>
            <div class="stat-label">Âä†ËΩΩÂ§±Ë¥•</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="avgLoadTime">0ms</span>
            <div class="stat-label">Âπ≥ÂùáÂä†ËΩΩÊó∂Èó¥</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="scrollPosition">0%</span>
            <div class="stat-label">ÊªöÂä®ËøõÂ∫¶</div>
        </div>
    </div>

    <!-- ‰∏ªÂÆπÂô® -->
    <div class="container">
        <div class="waterfall" id="waterfall">
            <!-- Âä®ÊÄÅÁîüÊàêÁöÑÁÄëÂ∏ÉÊµÅÈ°πÁõÆ -->
        </div>

        <!-- Âä†ËΩΩÊõ¥Â§öÊåâÈíÆ -->
        <div class="load-more" id="loadMoreBtn" style="display: none;">
            <button class="btn" onclick="loadMoreImages()">üì• Âä†ËΩΩÊõ¥Â§ö</button>
        </div>

        <!-- Êó†ÈôêÊªöÂä®Âä†ËΩΩÊåáÁ§∫Âô® -->
        <div class="infinite-loading" id="infiniteLoading" style="display: none;">
            <div class="spinner"></div>
            Ê≠£Âú®Âä†ËΩΩÊõ¥Â§öÂõæÁâá...
        </div>
    </div>

    <!-- ÂõæÁâáÈ¢ÑËßàÊ®°ÊÄÅÊ°Ü -->
    <div class="modal" id="imageModal" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <img id="modalImage" src="" alt="">
        </div>
    </div>

    <script>
        /**
         * Áé∞‰ª£ÂåñÁÄëÂ∏ÉÊµÅÁ±ª - ÈõÜÊàêÊáíÂä†ËΩΩ„ÄÅËôöÊãüÊªöÂä®„ÄÅÂìçÂ∫îÂºèÁ≠âÂäüËÉΩ
         */
        class ModernWaterfall {
            constructor(options = {}) {
                // ÈªòËÆ§ÈÖçÁΩÆ
                this.options = {
                    container: '#waterfall',
                    itemsPerLoad: 20,
                    maxConcurrent: 4,
                    retryCount: 3,
                    retryDelay: 1000,
                    skeletonDuration: 600,
                    rootMargin: '100px 0px 200px 0px',
                    threshold: 0.01,
                    debug: false,
                    lazyLoad: true,
                    infiniteScroll: true,
                    ...options
                };

                // Áä∂ÊÄÅÁÆ°ÁêÜ
                this.stats = {
                    total: 0,
                    loaded: 0,
                    loading: 0,
                    error: 0
                };

                // ÊÄßËÉΩÁõëÊéß
                this.performance = {
                    loadTimes: [],
                    startTime: Date.now()
                };

                // ÂÜÖÈÉ®Áä∂ÊÄÅ
                this.container = document.querySelector(this.options.container);
                this.observer = null;
                this.loadingQueue = new Set();
                this.retryMap = new Map();
                this.currentPage = 0;
                this.isLoading = false;
                this.hasMore = true;

                // ÂõæÁâáÊï∞ÊçÆÊ∫ê
                this.imagePool = this.generateImagePool();

                this.init();
            }

            init() {
                this.log('ÂàùÂßãÂåñÁé∞‰ª£ÂåñÁÄëÂ∏ÉÊµÅ...');
                this.createObserver();
                this.bindEvents();
                this.loadInitialImages();
                this.log('ÁÄëÂ∏ÉÊµÅÂàùÂßãÂåñÂÆåÊàê');
            }

            generateImagePool() {
                const pool = [];
                for (let i = 1; i <= 35; i++) {
                    pool.push(`images/${i}.png`);
                }
                return pool;
            }

            createObserver() {
                if (!this.options.lazyLoad || !('IntersectionObserver' in window)) {
                    this.log('ÊáíÂä†ËΩΩÂ∑≤Á¶ÅÁî®Êàñ‰∏çÊîØÊåÅ IntersectionObserver');
                    return;
                }

                this.observer = new IntersectionObserver(
                    (entries) => this.handleIntersection(entries),
                    {
                        rootMargin: this.options.rootMargin,
                        threshold: this.options.threshold
                    }
                );
            }

            handleIntersection(entries) {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const item = entry.target;
                        this.loadImage(item);

                        if (this.observer) {
                            this.observer.unobserve(item);
                        }
                    }
                });
            }

            async loadImage(item) {
                const img = item.querySelector('img');
                const src = img.dataset.src;

                if (!src || this.loadingQueue.has(item)) return;

                this.loadingQueue.add(item);
                this.updateStats('loading', 1);
                this.updateImageStatus(item, 'loading');

                const startTime = Date.now();
                const skeleton = item.querySelector('.skeleton');

                try {
                    // Á°Æ‰øùÈ™®Êû∂Â±èÊòæÁ§∫Ë∂≥Â§üÊó∂Èó¥
                    const [loadResult] = await Promise.all([
                        this.preloadImage(src),
                        this.delay(this.options.skeletonDuration)
                    ]);

                    // Âä†ËΩΩÊàêÂäü
                    img.src = src;
                    img.classList.add('loaded');

                    // ÈöêËóèÈ™®Êû∂Â±è
                    if (skeleton) {
                        skeleton.classList.add('hide');
                        setTimeout(() => skeleton.remove(), 300);
                    }

                    this.updateImageStatus(item, 'loaded');
                    this.updateStats('loading', -1);
                    this.updateStats('loaded', 1);

                    // ËÆ∞ÂΩïÊÄßËÉΩÊï∞ÊçÆ
                    const loadTime = Date.now() - startTime;
                    this.performance.loadTimes.push(loadTime);

                    this.log('‚úÖ ÂõæÁâáÂä†ËΩΩÊàêÂäü:', src, 'ËÄóÊó∂:', loadTime + 'ms');

                    // ÈáçÊñ∞ËÆ°ÁÆóÁΩëÊ†ºÂ∏ÉÂ±Ä
                    this.updateGridLayout(item);

                } catch (error) {
                    this.log('‚ùå ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•:', src, error);
                    await this.handleImageError(item, src, skeleton, error);
                } finally {
                    this.loadingQueue.delete(item);
                }
            }

            preloadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load: ${src}`));
                    setTimeout(() => reject(new Error('Load timeout')), 10000);
                    img.src = src;
                });
            }

            async handleImageError(item, src, skeleton, error) {
                const retryCount = this.retryMap.get(item) || 0;

                if (retryCount < this.options.retryCount) {
                    this.retryMap.set(item, retryCount + 1);
                    await this.delay(this.options.retryDelay * (retryCount + 1));

                    try {
                        const img = item.querySelector('img');
                        await this.preloadImage(src);
                        img.src = src;
                        img.classList.add('loaded');
                        this.updateImageStatus(item, 'loaded');
                        this.updateStats('loading', -1);
                        this.updateStats('loaded', 1);
                        return;
                    } catch (retryError) {
                        this.log(`ÈáçËØï ${retryCount + 1} Â§±Ë¥•:`, src);
                    }
                }

                // ÊúÄÁªàÂ§±Ë¥•Â§ÑÁêÜ
                this.handleFinalError(item, skeleton);
            }

            handleFinalError(item, skeleton) {
                const errorPlaceholder = document.createElement('div');
                errorPlaceholder.className = 'error-placeholder';
                errorPlaceholder.innerHTML = `
          <div class="error-icon">üñºÔ∏è</div>
          <div>ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•</div>
        `;

                item.appendChild(errorPlaceholder);

                if (skeleton) {
                    skeleton.classList.add('hide');
                    setTimeout(() => skeleton.remove(), 300);
                }

                const img = item.querySelector('img');
                img.classList.add('error');
                this.updateImageStatus(item, 'error');
                this.updateStats('loading', -1);
                this.updateStats('error', 1);
            }

            updateImageStatus(item, status) {
                const indicator = item.querySelector('.loading-indicator');
                if (indicator) {
                    indicator.className = `loading-indicator status-${status}`;
                    indicator.textContent = {
                        loading: 'Âä†ËΩΩ‰∏≠...',
                        loaded: 'Â∑≤Âä†ËΩΩ',
                        error: 'Âä†ËΩΩÂ§±Ë¥•'
                    }[status];
                }
            }

            updateGridLayout(item) {
                // ‰ΩøÁî® ResizeObserver Êàñ setTimeout Êù•ÈáçÊñ∞ËÆ°ÁÆóÂ∏ÉÂ±Ä
                setTimeout(() => {
                    const img = item.querySelector('img');
                    if (img.complete && img.naturalHeight > 0) {
                        const aspectRatio = img.naturalHeight / img.naturalWidth;
                        const gridRowEnd = Math.ceil((280 * aspectRatio + 20) / 10);
                        item.style.gridRowEnd = `span ${gridRowEnd}`;
                    }
                }, 100);
            }

            createWaterfallItem(src, index) {
                const item = document.createElement('div');
                item.className = 'waterfall-item';
                item.innerHTML = `
          <div class="skeleton"></div>
          <img data-src="${src}" alt="ÂõæÁâá ${index + 1}" />
          <div class="loading-indicator status-loading">Á≠âÂæÖÂä†ËΩΩ #${index + 1}</div>
        `;

                // Ê∑ªÂä†ÁÇπÂáªÈ¢ÑËßàÂäüËÉΩ
                item.addEventListener('click', () => this.previewImage(src));

                return item;
            }

            previewImage(src) {
                const modal = document.getElementById('imageModal');
                const modalImg = document.getElementById('modalImage');
                modalImg.src = src;
                modal.classList.add('show');
            }

            loadInitialImages() {
                this.loadMoreImages();
            }

            loadMoreImages() {
                if (this.isLoading || !this.hasMore) return;

                this.isLoading = true;
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < this.options.itemsPerLoad; i++) {
                    const imageIndex = (this.currentPage * this.options.itemsPerLoad + i) % this.imagePool.length;
                    const src = this.imagePool[imageIndex];
                    const globalIndex = this.currentPage * this.options.itemsPerLoad + i;

                    const item = this.createWaterfallItem(src, globalIndex);
                    fragment.appendChild(item);

                    this.stats.total++;

                    // Â¶ÇÊûúÂêØÁî®ÊáíÂä†ËΩΩÔºåËßÇÂØüËØ•È°πÁõÆ
                    if (this.options.lazyLoad && this.observer) {
                        setTimeout(() => this.observer.observe(item), 100);
                    } else {
                        // Áõ¥Êé•Âä†ËΩΩ
                        setTimeout(() => this.loadImage(item), 100);
                    }
                }

                this.container.appendChild(fragment);
                this.currentPage++;

                // Ê®°ÊãüÊòØÂê¶ËøòÊúâÊõ¥Â§öÊï∞ÊçÆ
                if (this.currentPage >= 10) {
                    this.hasMore = false;
                }

                this.updateStatsDisplay();
                this.isLoading = false;

                this.log(`Âä†ËΩΩ‰∫Ü ${this.options.itemsPerLoad} Âº†ÂõæÁâáÔºåÂΩìÂâçÈ°µÔºö${this.currentPage}`);
            }

            bindEvents() {
                // Êó†ÈôêÊªöÂä®
                if (this.options.infiniteScroll) {
                    let ticking = false;

                    window.addEventListener('scroll', () => {
                        if (!ticking) {
                            requestAnimationFrame(() => {
                                this.handleScroll();
                                this.updateScrollProgress();
                                ticking = false;
                            });
                            ticking = true;
                        }
                    });
                }

                // Á™óÂè£Â§ßÂ∞èÂèòÂåñ
                window.addEventListener('resize', this.debounce(() => {
                    this.recalculateLayout();
                }, 300));

                // È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñ
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseLoading = true;
                    } else {
                        this.pauseLoading = false;
                    }
                });
            }

            handleScroll() {
                if (!this.options.infiniteScroll || this.isLoading || !this.hasMore) return;

                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;

                // ÂΩìÊªöÂä®Âà∞Ë∑ùÁ¶ªÂ∫ïÈÉ®200pxÊó∂Âä†ËΩΩÊõ¥Â§ö
                if (scrollTop + windowHeight >= documentHeight - 200) {
                    this.showInfiniteLoading();
                    setTimeout(() => {
                        this.loadMoreImages();
                        this.hideInfiniteLoading();
                    }, 500);
                }
            }

            updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
                const progress = Math.round((scrollTop / documentHeight) * 100);
                document.getElementById('scrollPosition').textContent = progress + '%';
            }

            showInfiniteLoading() {
                document.getElementById('infiniteLoading').style.display = 'block';
            }

            hideInfiniteLoading() {
                document.getElementById('infiniteLoading').style.display = 'none';
            }

            recalculateLayout() {
                // ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÂ∑≤Âä†ËΩΩÂõæÁâáÁöÑÁΩëÊ†ºÂ∏ÉÂ±Ä
                const items = this.container.querySelectorAll('.waterfall-item');
                items.forEach(item => {
                    const img = item.querySelector('img');
                    if (img.complete && img.naturalHeight > 0) {
                        this.updateGridLayout(item);
                    }
                });
            }

            updateStats(type, delta) {
                this.stats[type] += delta;
                this.updateStatsDisplay();
            }

            updateStatsDisplay() {
                document.getElementById('totalItems').textContent = this.stats.total;
                document.getElementById('loadedItems').textContent = this.stats.loaded;
                document.getElementById('loadingItems').textContent = this.stats.loading;
                document.getElementById('errorItems').textContent = this.stats.error;

                const avgTime = this.performance.loadTimes.length > 0
                    ? Math.round(this.performance.loadTimes.reduce((a, b) => a + b, 0) / this.performance.loadTimes.length)
                    : 0;
                document.getElementById('avgLoadTime').textContent = avgTime + 'ms';
            }

            // Â∑•ÂÖ∑ÊñπÊ≥ï
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            log(...args) {
                if (this.options.debug) {
                    console.log('[ModernWaterfall]', ...args);
                }
            }

            // ÂÖ¨ÂÖ±ÊñπÊ≥ï
            toggleLazyLoad() {
                this.options.lazyLoad = !this.options.lazyLoad;
                this.log('ÊáíÂä†ËΩΩÂ∑≤', this.options.lazyLoad ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
            }

            toggleInfiniteScroll() {
                this.options.infiniteScroll = !this.options.infiniteScroll;
                this.log('Êó†ÈôêÊªöÂä®Â∑≤', this.options.infiniteScroll ? 'ÂêØÁî®' : 'Á¶ÅÁî®');

                const loadMoreBtn = document.getElementById('loadMoreBtn');
                loadMoreBtn.style.display = this.options.infiniteScroll ? 'none' : 'block';
            }

            toggleDebug() {
                this.options.debug = !this.options.debug;
                this.log('Ë∞ÉËØïÊ®°ÂºèÂ∑≤', this.options.debug ? 'ÂêØÁî®' : 'Á¶ÅÁî®');
            }

            reset() {
                this.container.innerHTML = '';
                this.stats = { total: 0, loaded: 0, loading: 0, error: 0 };
                this.performance = { loadTimes: [], startTime: Date.now() };
                this.currentPage = 0;
                this.isLoading = false;
                this.hasMore = true;
                this.loadingQueue.clear();
                this.retryMap.clear();
                this.updateStatsDisplay();
                this.loadInitialImages();
            }

            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
                this.container.innerHTML = '';
                this.log('ÁÄëÂ∏ÉÊµÅÂ∑≤ÈîÄÊØÅ');
            }
        }

        // ÂÖ®Â±ÄÂèòÈáè
        let waterfall;

        // ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function () {
            waterfall = new ModernWaterfall({
                container: '#waterfall',
                itemsPerLoad: 20,
                maxConcurrent: 4,
                debug: false,
                lazyLoad: true,
                infiniteScroll: true
            });
        });

        // ÂÖ®Â±ÄÊéßÂà∂ÂáΩÊï∞
        function toggleLazyLoad() {
            waterfall.toggleLazyLoad();
            const btn = document.getElementById('lazyBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.lazyLoad ? 'üí§ ÊáíÂä†ËΩΩ (ÂºÄ)' : 'üí§ ÊáíÂä†ËΩΩ';
        }

        function toggleInfiniteScroll() {
            waterfall.toggleInfiniteScroll();
            const btn = document.getElementById('infiniteBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.infiniteScroll ? '‚ôæÔ∏è Êó†ÈôêÊªöÂä® (ÂºÄ)' : '‚ôæÔ∏è Êó†ÈôêÊªöÂä®';
        }

        function changeColumns() {
            const waterfallEl = document.getElementById('waterfall');
            const currentColumns = getComputedStyle(waterfallEl).gridTemplateColumns.split(' ').length;

            let newMinWidth;
            switch (currentColumns) {
                case 1: newMinWidth = '200px'; break;
                case 2: newMinWidth = '250px'; break;
                case 3: newMinWidth = '300px'; break;
                default: newMinWidth = '350px'; break;
            }

            waterfallEl.style.gridTemplateColumns = `repeat(auto-fill, minmax(${newMinWidth}, 1fr))`;

            setTimeout(() => {
                waterfall.recalculateLayout();
            }, 100);
        }

        function toggleDebug() {
            waterfall.toggleDebug();
            const btn = document.getElementById('debugBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.debug ? 'üêõ Ë∞ÉËØï (ÂºÄ)' : 'üêõ Ë∞ÉËØï';
        }

        function resetWaterfall() {
            waterfall.reset();
        }

        function loadMoreImages() {
            waterfall.loadMoreImages();
        }

        function closeModal() {
            document.getElementById('imageModal').classList.remove('show');
        }

        // ÈîÆÁõò‰∫ã‰ª∂
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    </script>
</body>

</html>