<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>ğŸš€ ç°ä»£åŒ–ç€‘å¸ƒæµ - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            line-height: 1.6;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .title {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: #667eea;
            color: white;
            min-width: 80px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn.active {
            background: #28a745;
        }

        .stats {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            margin: 20px auto;
            max-width: 1400px;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-around;
            text-align: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-item {
            flex: 1;
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px 40px;
            position: relative;
        }

        .waterfall {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            grid-auto-rows: 10px;
        }

        .waterfall-item {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            cursor: pointer;
        }

        .waterfall-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .waterfall-item img {
            width: 100%;
            height: auto;
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .waterfall-item img.loaded {
            opacity: 1;
        }

        .waterfall-item img.error {
            opacity: 0.5;
        }

        /* éª¨æ¶å± */
        .skeleton {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(90deg,
                    #f0f0f0 25%,
                    #e0e0e0 37%,
                    #f0f0f0 63%);
            background-size: 400% 100%;
            animation: skeleton-loading 1.4s ease infinite;
            transition: opacity 0.3s ease;
        }

        .skeleton.hide {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes skeleton-loading {
            0% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0 50%;
            }
        }

        /* åŠ è½½çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .loading-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
            z-index: 10;
        }

        .status-loading {
            background: rgba(255, 193, 7, 0.9);
            color: #856404;
        }

        .status-loaded {
            background: rgba(40, 167, 69, 0.9);
            color: white;
        }

        .status-error {
            background: rgba(220, 53, 69, 0.9);
            color: white;
        }

        /* é”™è¯¯å ä½ç¬¦ */
        .error-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: #f8f9fa;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .error-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        /* åŠ è½½æ›´å¤šæŒ‰é’® */
        .load-more {
            text-align: center;
            margin: 40px 0;
        }

        .load-more .btn {
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 25px;
        }

        /* æ— é™æ»šåŠ¨åŠ è½½æŒ‡ç¤ºå™¨ */
        .infinite-loading {
            text-align: center;
            padding: 40px;
            font-size: 1.1rem;
            color: white;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1200px) {
            .waterfall {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .waterfall {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 15px;
            }

            .stats {
                flex-direction: column;
                gap: 15px;
            }

            .container {
                padding: 0 15px 30px;
            }
        }

        @media (max-width: 480px) {
            .waterfall {
                grid-template-columns: 1fr;
            }

            .controls {
                justify-content: center;
                width: 100%;
            }
        }

        /* æ·±è‰²ä¸»é¢˜æ”¯æŒ */
        @media (prefers-color-scheme: dark) {
            .skeleton {
                background: linear-gradient(90deg,
                        #2a2a2a 25%,
                        #3a3a3a 37%,
                        #2a2a2a 63%);
            }

            .waterfall-item {
                background: #2c2c2c;
            }

            .error-placeholder {
                background: #1a1a1a;
                color: #ffffff;
            }
        }

        /* å‡å°‘åŠ¨ç”»åå¥½æ”¯æŒ */
        @media (prefers-reduced-motion: reduce) {
            .skeleton {
                animation: none;
                background: #e0e0e0;
            }

            .waterfall-item img {
                transition: none;
            }

            .waterfall-item {
                transition: none;
            }
        }

        /* å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .modal img {
            width: 100%;
            height: auto;
            display: block;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>

<body>
    <!-- å¤´éƒ¨ -->
    <div class="header">
        <div class="header-content">
            <h1 class="title">ğŸš€ ç°ä»£åŒ–ç€‘å¸ƒæµ</h1>
            <div class="controls">
                <button class="btn" onclick="toggleLazyLoad()" id="lazyBtn">ğŸ’¤ æ‡’åŠ è½½</button>
                <button class="btn" onclick="toggleInfiniteScroll()" id="infiniteBtn">â™¾ï¸ æ— é™æ»šåŠ¨</button>
                <button class="btn" onclick="changeColumns()" id="columnsBtn">ğŸ“± å“åº”å¼</button>
                <button class="btn" onclick="toggleDebug()" id="debugBtn">ğŸ› è°ƒè¯•</button>
                <button class="btn" onclick="resetWaterfall()">ğŸ”„ é‡ç½®</button>
            </div>
        </div>
    </div>

    <!-- ç»Ÿè®¡é¢æ¿ -->
    <div class="stats">
        <div class="stat-item">
            <span class="stat-number" id="totalItems">0</span>
            <div class="stat-label">æ€»å›¾ç‰‡æ•°</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="loadedItems">0</span>
            <div class="stat-label">å·²åŠ è½½</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="loadingItems">0</span>
            <div class="stat-label">åŠ è½½ä¸­</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="errorItems">0</span>
            <div class="stat-label">åŠ è½½å¤±è´¥</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="avgLoadTime">0ms</span>
            <div class="stat-label">å¹³å‡åŠ è½½æ—¶é—´</div>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="scrollPosition">0%</span>
            <div class="stat-label">æ»šåŠ¨è¿›åº¦</div>
        </div>
    </div>

    <!-- ä¸»å®¹å™¨ -->
    <div class="container">
        <div class="waterfall" id="waterfall">
            <!-- åŠ¨æ€ç”Ÿæˆçš„ç€‘å¸ƒæµé¡¹ç›® -->
        </div>

        <!-- åŠ è½½æ›´å¤šæŒ‰é’® -->
        <div class="load-more" id="loadMoreBtn" style="display: none;">
            <button class="btn" onclick="loadMoreImages()">ğŸ“¥ åŠ è½½æ›´å¤š</button>
        </div>

        <!-- æ— é™æ»šåŠ¨åŠ è½½æŒ‡ç¤ºå™¨ -->
        <div class="infinite-loading" id="infiniteLoading" style="display: none;">
            <div class="spinner"></div>
            æ­£åœ¨åŠ è½½æ›´å¤šå›¾ç‰‡...
        </div>
    </div>

    <!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
    <div class="modal" id="imageModal" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeModal()">Ã—</button>
            <img id="modalImage" src="" alt="">
        </div>
    </div>

    <script>
        /**
         * ç°ä»£åŒ–ç€‘å¸ƒæµç±» - é›†æˆæ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ã€å“åº”å¼ç­‰åŠŸèƒ½
         */
        class ModernWaterfall {
            constructor(options = {}) {
                // é»˜è®¤é…ç½®
                this.options = {
                    container: '#waterfall',
                    itemsPerLoad: 20,
                    maxConcurrent: 4,
                    retryCount: 3,
                    retryDelay: 1000,
                    skeletonDuration: 600,
                    rootMargin: '100px 0px 200px 0px',
                    threshold: 0.01,
                    debug: false,
                    lazyLoad: true,
                    infiniteScroll: true,
                    ...options
                };

                // çŠ¶æ€ç®¡ç†
                this.stats = {
                    total: 0,
                    loaded: 0,
                    loading: 0,
                    error: 0
                };

                // æ€§èƒ½ç›‘æ§
                this.performance = {
                    loadTimes: [],
                    startTime: Date.now()
                };

                // å†…éƒ¨çŠ¶æ€
                this.container = document.querySelector(this.options.container);
                this.observer = null;
                this.loadingQueue = new Set();
                this.retryMap = new Map();
                this.currentPage = 0;
                this.isLoading = false;
                this.hasMore = true;

                // å›¾ç‰‡æ•°æ®æº
                this.imagePool = this.generateImagePool();

                this.init();
            }

            init() {
                this.log('åˆå§‹åŒ–ç°ä»£åŒ–ç€‘å¸ƒæµ...');
                this.createObserver();
                this.bindEvents();
                this.loadInitialImages();
                this.log('ç€‘å¸ƒæµåˆå§‹åŒ–å®Œæˆ');
            }

            generateImagePool() {
                const pool = [];
                for (let i = 1; i <= 35; i++) {
                    pool.push(`images/${i}.png`);
                }
                return pool;
            }

            createObserver() {
                if (!this.options.lazyLoad || !('IntersectionObserver' in window)) {
                    this.log('æ‡’åŠ è½½å·²ç¦ç”¨æˆ–ä¸æ”¯æŒ IntersectionObserver');
                    return;
                }

                this.observer = new IntersectionObserver(
                    (entries) => this.handleIntersection(entries),
                    {
                        rootMargin: this.options.rootMargin,
                        threshold: this.options.threshold
                    }
                );
            }

            handleIntersection(entries) {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const item = entry.target;
                        this.loadImage(item);

                        if (this.observer) {
                            this.observer.unobserve(item);
                        }
                    }
                });
            }

            async loadImage(item) {
                const img = item.querySelector('img');
                const src = img.dataset.src;

                if (!src || this.loadingQueue.has(item)) return;

                this.loadingQueue.add(item);
                this.updateStats('loading', 1);
                this.updateImageStatus(item, 'loading');

                const startTime = Date.now();
                const skeleton = item.querySelector('.skeleton');

                try {
                    // ç¡®ä¿éª¨æ¶å±æ˜¾ç¤ºè¶³å¤Ÿæ—¶é—´
                    const [loadResult] = await Promise.all([
                        this.preloadImage(src),
                        this.delay(this.options.skeletonDuration)
                    ]);

                    // åŠ è½½æˆåŠŸ
                    img.src = src;
                    img.classList.add('loaded');

                    // éšè—éª¨æ¶å±
                    if (skeleton) {
                        skeleton.classList.add('hide');
                        setTimeout(() => skeleton.remove(), 300);
                    }

                    this.updateImageStatus(item, 'loaded');
                    this.updateStats('loading', -1);
                    this.updateStats('loaded', 1);

                    // è®°å½•æ€§èƒ½æ•°æ®
                    const loadTime = Date.now() - startTime;
                    this.performance.loadTimes.push(loadTime);

                    this.log('âœ… å›¾ç‰‡åŠ è½½æˆåŠŸ:', src, 'è€—æ—¶:', loadTime + 'ms');

                    // é‡æ–°è®¡ç®—ç½‘æ ¼å¸ƒå±€
                    this.updateGridLayout(item);

                } catch (error) {
                    this.log('âŒ å›¾ç‰‡åŠ è½½å¤±è´¥:', src, error);
                    await this.handleImageError(item, src, skeleton, error);
                } finally {
                    this.loadingQueue.delete(item);
                }
            }

            preloadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load: ${src}`));
                    setTimeout(() => reject(new Error('Load timeout')), 10000);
                    img.src = src;
                });
            }

            async handleImageError(item, src, skeleton, error) {
                const retryCount = this.retryMap.get(item) || 0;

                if (retryCount < this.options.retryCount) {
                    this.retryMap.set(item, retryCount + 1);
                    await this.delay(this.options.retryDelay * (retryCount + 1));

                    try {
                        const img = item.querySelector('img');
                        await this.preloadImage(src);
                        img.src = src;
                        img.classList.add('loaded');
                        this.updateImageStatus(item, 'loaded');
                        this.updateStats('loading', -1);
                        this.updateStats('loaded', 1);
                        return;
                    } catch (retryError) {
                        this.log(`é‡è¯• ${retryCount + 1} å¤±è´¥:`, src);
                    }
                }

                // æœ€ç»ˆå¤±è´¥å¤„ç†
                this.handleFinalError(item, skeleton);
            }

            handleFinalError(item, skeleton) {
                const errorPlaceholder = document.createElement('div');
                errorPlaceholder.className = 'error-placeholder';
                errorPlaceholder.innerHTML = `
          <div class="error-icon">ğŸ–¼ï¸</div>
          <div>å›¾ç‰‡åŠ è½½å¤±è´¥</div>
        `;

                item.appendChild(errorPlaceholder);

                if (skeleton) {
                    skeleton.classList.add('hide');
                    setTimeout(() => skeleton.remove(), 300);
                }

                const img = item.querySelector('img');
                img.classList.add('error');
                this.updateImageStatus(item, 'error');
                this.updateStats('loading', -1);
                this.updateStats('error', 1);
            }

            updateImageStatus(item, status) {
                const indicator = item.querySelector('.loading-indicator');
                if (indicator) {
                    indicator.className = `loading-indicator status-${status}`;
                    indicator.textContent = {
                        loading: 'åŠ è½½ä¸­...',
                        loaded: 'å·²åŠ è½½',
                        error: 'åŠ è½½å¤±è´¥'
                    }[status];
                }
            }

            updateGridLayout(item) {
                // ä½¿ç”¨ ResizeObserver æˆ– setTimeout æ¥é‡æ–°è®¡ç®—å¸ƒå±€
                setTimeout(() => {
                    const img = item.querySelector('img');
                    if (img.complete && img.naturalHeight > 0) {
                        const aspectRatio = img.naturalHeight / img.naturalWidth;
                        const gridRowEnd = Math.ceil((280 * aspectRatio + 20) / 10);
                        item.style.gridRowEnd = `span ${gridRowEnd}`;
                    }
                }, 100);
            }

            createWaterfallItem(src, index) {
                const item = document.createElement('div');
                item.className = 'waterfall-item';
                item.innerHTML = `
          <div class="skeleton"></div>
          <img data-src="${src}" alt="å›¾ç‰‡ ${index + 1}" />
          <div class="loading-indicator status-loading">ç­‰å¾…åŠ è½½ #${index + 1}</div>
        `;

                // æ·»åŠ ç‚¹å‡»é¢„è§ˆåŠŸèƒ½
                item.addEventListener('click', () => this.previewImage(src));

                return item;
            }

            previewImage(src) {
                const modal = document.getElementById('imageModal');
                const modalImg = document.getElementById('modalImage');
                modalImg.src = src;
                modal.classList.add('show');
            }

            loadInitialImages() {
                this.loadMoreImages();
            }

            loadMoreImages() {
                if (this.isLoading || !this.hasMore) return;

                this.isLoading = true;
                const fragment = document.createDocumentFragment();

                for (let i = 0; i < this.options.itemsPerLoad; i++) {
                    const imageIndex = (this.currentPage * this.options.itemsPerLoad + i) % this.imagePool.length;
                    const src = this.imagePool[imageIndex];
                    const globalIndex = this.currentPage * this.options.itemsPerLoad + i;

                    const item = this.createWaterfallItem(src, globalIndex);
                    fragment.appendChild(item);

                    this.stats.total++;

                    // å¦‚æœå¯ç”¨æ‡’åŠ è½½ï¼Œè§‚å¯Ÿè¯¥é¡¹ç›®
                    if (this.options.lazyLoad && this.observer) {
                        setTimeout(() => this.observer.observe(item), 100);
                    } else {
                        // ç›´æ¥åŠ è½½
                        setTimeout(() => this.loadImage(item), 100);
                    }
                }

                this.container.appendChild(fragment);
                this.currentPage++;

                // æ¨¡æ‹Ÿæ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
                if (this.currentPage >= 10) {
                    this.hasMore = false;
                }

                this.updateStatsDisplay();
                this.isLoading = false;

                this.log(`åŠ è½½äº† ${this.options.itemsPerLoad} å¼ å›¾ç‰‡ï¼Œå½“å‰é¡µï¼š${this.currentPage}`);
            }

            bindEvents() {
                // æ— é™æ»šåŠ¨
                if (this.options.infiniteScroll) {
                    let ticking = false;

                    window.addEventListener('scroll', () => {
                        if (!ticking) {
                            requestAnimationFrame(() => {
                                this.handleScroll();
                                this.updateScrollProgress();
                                ticking = false;
                            });
                            ticking = true;
                        }
                    });
                }

                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', this.debounce(() => {
                    this.recalculateLayout();
                }, 300));

                // é¡µé¢å¯è§æ€§å˜åŒ–
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseLoading = true;
                    } else {
                        this.pauseLoading = false;
                    }
                });
            }

            handleScroll() {
                if (!this.options.infiniteScroll || this.isLoading || !this.hasMore) return;

                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;

                // å½“æ»šåŠ¨åˆ°è·ç¦»åº•éƒ¨200pxæ—¶åŠ è½½æ›´å¤š
                if (scrollTop + windowHeight >= documentHeight - 200) {
                    this.showInfiniteLoading();
                    setTimeout(() => {
                        this.loadMoreImages();
                        this.hideInfiniteLoading();
                    }, 500);
                }
            }

            updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
                const progress = Math.round((scrollTop / documentHeight) * 100);
                document.getElementById('scrollPosition').textContent = progress + '%';
            }

            showInfiniteLoading() {
                document.getElementById('infiniteLoading').style.display = 'block';
            }

            hideInfiniteLoading() {
                document.getElementById('infiniteLoading').style.display = 'none';
            }

            recalculateLayout() {
                // é‡æ–°è®¡ç®—æ‰€æœ‰å·²åŠ è½½å›¾ç‰‡çš„ç½‘æ ¼å¸ƒå±€
                const items = this.container.querySelectorAll('.waterfall-item');
                items.forEach(item => {
                    const img = item.querySelector('img');
                    if (img.complete && img.naturalHeight > 0) {
                        this.updateGridLayout(item);
                    }
                });
            }

            updateStats(type, delta) {
                this.stats[type] += delta;
                this.updateStatsDisplay();
            }

            updateStatsDisplay() {
                document.getElementById('totalItems').textContent = this.stats.total;
                document.getElementById('loadedItems').textContent = this.stats.loaded;
                document.getElementById('loadingItems').textContent = this.stats.loading;
                document.getElementById('errorItems').textContent = this.stats.error;

                const avgTime = this.performance.loadTimes.length > 0
                    ? Math.round(this.performance.loadTimes.reduce((a, b) => a + b, 0) / this.performance.loadTimes.length)
                    : 0;
                document.getElementById('avgLoadTime').textContent = avgTime + 'ms';
            }

            // å·¥å…·æ–¹æ³•
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            log(...args) {
                if (this.options.debug) {
                    console.log('[ModernWaterfall]', ...args);
                }
            }

            // å…¬å…±æ–¹æ³•
            toggleLazyLoad() {
                this.options.lazyLoad = !this.options.lazyLoad;
                this.log('æ‡’åŠ è½½å·²', this.options.lazyLoad ? 'å¯ç”¨' : 'ç¦ç”¨');
            }

            toggleInfiniteScroll() {
                this.options.infiniteScroll = !this.options.infiniteScroll;
                this.log('æ— é™æ»šåŠ¨å·²', this.options.infiniteScroll ? 'å¯ç”¨' : 'ç¦ç”¨');

                const loadMoreBtn = document.getElementById('loadMoreBtn');
                loadMoreBtn.style.display = this.options.infiniteScroll ? 'none' : 'block';
            }

            toggleDebug() {
                this.options.debug = !this.options.debug;
                this.log('è°ƒè¯•æ¨¡å¼å·²', this.options.debug ? 'å¯ç”¨' : 'ç¦ç”¨');
            }

            reset() {
                this.container.innerHTML = '';
                this.stats = { total: 0, loaded: 0, loading: 0, error: 0 };
                this.performance = { loadTimes: [], startTime: Date.now() };
                this.currentPage = 0;
                this.isLoading = false;
                this.hasMore = true;
                this.loadingQueue.clear();
                this.retryMap.clear();
                this.updateStatsDisplay();
                this.loadInitialImages();
            }

            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
                this.container.innerHTML = '';
                this.log('ç€‘å¸ƒæµå·²é”€æ¯');
            }
        }

        // å…¨å±€å˜é‡
        let waterfall;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function () {
            waterfall = new ModernWaterfall({
                container: '#waterfall',
                itemsPerLoad: 20,
                maxConcurrent: 4,
                debug: false,
                lazyLoad: true,
                infiniteScroll: true
            });
        });

        // å…¨å±€æ§åˆ¶å‡½æ•°
        function toggleLazyLoad() {
            waterfall.toggleLazyLoad();
            const btn = document.getElementById('lazyBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.lazyLoad ? 'ğŸ’¤ æ‡’åŠ è½½ (å¼€)' : 'ğŸ’¤ æ‡’åŠ è½½';
        }

        function toggleInfiniteScroll() {
            waterfall.toggleInfiniteScroll();
            const btn = document.getElementById('infiniteBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.infiniteScroll ? 'â™¾ï¸ æ— é™æ»šåŠ¨ (å¼€)' : 'â™¾ï¸ æ— é™æ»šåŠ¨';
        }

        function changeColumns() {
            const waterfallEl = document.getElementById('waterfall');
            const currentColumns = getComputedStyle(waterfallEl).gridTemplateColumns.split(' ').length;

            let newMinWidth;
            switch (currentColumns) {
                case 1: newMinWidth = '200px'; break;
                case 2: newMinWidth = '250px'; break;
                case 3: newMinWidth = '300px'; break;
                default: newMinWidth = '350px'; break;
            }

            waterfallEl.style.gridTemplateColumns = `repeat(auto-fill, minmax(${newMinWidth}, 1fr))`;

            setTimeout(() => {
                waterfall.recalculateLayout();
            }, 100);
        }

        function toggleDebug() {
            waterfall.toggleDebug();
            const btn = document.getElementById('debugBtn');
            btn.classList.toggle('active');
            btn.textContent = waterfall.options.debug ? 'ğŸ› è°ƒè¯• (å¼€)' : 'ğŸ› è°ƒè¯•';
        }

        function resetWaterfall() {
            waterfall.reset();
        }

        function loadMoreImages() {
            waterfall.loadMoreImages();
        }

        function closeModal() {
            document.getElementById('imageModal').classList.remove('show');
        }

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    </script>
</body>

</html>